// This file was auto-generated by Fern from our API Definition.

package schematichq

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/schematichq/schematic-go/internal"
	time "time"
)

type CountBillingProductsRequest struct {
	IDs            []*string                                  `json:"-" url:"ids,omitempty"`
	Name           *string                                    `json:"-" url:"name,omitempty"`
	Q              *string                                    `json:"-" url:"q,omitempty"`
	PriceUsageType *CountBillingProductsRequestPriceUsageType `json:"-" url:"price_usage_type,omitempty"`
	// Filter products that are not linked to any plan
	WithoutLinkedToPlan *bool `json:"-" url:"without_linked_to_plan,omitempty"`
	// Filter products that are one time charges
	WithOneTimeCharges *bool `json:"-" url:"with_one_time_charges,omitempty"`
	// Filter products that have zero price for free subscription type
	WithZeroPrice *bool `json:"-" url:"with_zero_price,omitempty"`
	// Filter products that have prices
	WithPricesOnly *bool `json:"-" url:"with_prices_only,omitempty"`
	// Filter products that are active
	IsActive *bool `json:"-" url:"is_active,omitempty"`
	// Page limit (default 100)
	Limit *int `json:"-" url:"limit,omitempty"`
	// Page offset (default 0)
	Offset *int `json:"-" url:"offset,omitempty"`
}

type CountCustomersRequest struct {
	CompanyIDs     []*string `json:"-" url:"company_ids,omitempty"`
	Name           *string   `json:"-" url:"name,omitempty"`
	FailedToImport *bool     `json:"-" url:"failed_to_import,omitempty"`
	Q              *string   `json:"-" url:"q,omitempty"`
	// Page limit (default 100)
	Limit *int `json:"-" url:"limit,omitempty"`
	// Page offset (default 0)
	Offset *int `json:"-" url:"offset,omitempty"`
}

type ListBillingProductsRequest struct {
	IDs            []*string                                 `json:"-" url:"ids,omitempty"`
	Name           *string                                   `json:"-" url:"name,omitempty"`
	Q              *string                                   `json:"-" url:"q,omitempty"`
	PriceUsageType *ListBillingProductsRequestPriceUsageType `json:"-" url:"price_usage_type,omitempty"`
	// Filter products that are not linked to any plan
	WithoutLinkedToPlan *bool `json:"-" url:"without_linked_to_plan,omitempty"`
	// Filter products that are one time charges
	WithOneTimeCharges *bool `json:"-" url:"with_one_time_charges,omitempty"`
	// Filter products that have zero price for free subscription type
	WithZeroPrice *bool `json:"-" url:"with_zero_price,omitempty"`
	// Filter products that have prices
	WithPricesOnly *bool `json:"-" url:"with_prices_only,omitempty"`
	// Filter products that are active
	IsActive *bool `json:"-" url:"is_active,omitempty"`
	// Page limit (default 100)
	Limit *int `json:"-" url:"limit,omitempty"`
	// Page offset (default 0)
	Offset *int `json:"-" url:"offset,omitempty"`
}

type ListCouponsRequest struct {
	IsActive *bool   `json:"-" url:"is_active,omitempty"`
	Q        *string `json:"-" url:"q,omitempty"`
	// Page limit (default 100)
	Limit *int `json:"-" url:"limit,omitempty"`
	// Page offset (default 0)
	Offset *int `json:"-" url:"offset,omitempty"`
}

type ListCustomersWithSubscriptionsRequest struct {
	CompanyIDs     []*string `json:"-" url:"company_ids,omitempty"`
	Name           *string   `json:"-" url:"name,omitempty"`
	FailedToImport *bool     `json:"-" url:"failed_to_import,omitempty"`
	Q              *string   `json:"-" url:"q,omitempty"`
	// Page limit (default 100)
	Limit *int `json:"-" url:"limit,omitempty"`
	// Page offset (default 0)
	Offset *int `json:"-" url:"offset,omitempty"`
}

type ListInvoicesRequest struct {
	CompanyID              *string `json:"-" url:"company_id,omitempty"`
	CustomerExternalID     string  `json:"-" url:"customer_external_id"`
	SubscriptionExternalID string  `json:"-" url:"subscription_external_id"`
	// Page limit (default 100)
	Limit *int `json:"-" url:"limit,omitempty"`
	// Page offset (default 0)
	Offset *int `json:"-" url:"offset,omitempty"`
}

type ListMetersRequest struct {
	DisplayName *string `json:"-" url:"display_name,omitempty"`
	// Page limit (default 100)
	Limit *int `json:"-" url:"limit,omitempty"`
	// Page offset (default 0)
	Offset *int `json:"-" url:"offset,omitempty"`
}

type ListPaymentMethodsRequest struct {
	CompanyID          *string `json:"-" url:"company_id,omitempty"`
	CustomerExternalID string  `json:"-" url:"customer_external_id"`
	// Page limit (default 100)
	Limit *int `json:"-" url:"limit,omitempty"`
	// Page offset (default 0)
	Offset *int `json:"-" url:"offset,omitempty"`
}

type ListProductPricesRequest struct {
	IDs            []*string                               `json:"-" url:"ids,omitempty"`
	Name           *string                                 `json:"-" url:"name,omitempty"`
	Q              *string                                 `json:"-" url:"q,omitempty"`
	PriceUsageType *ListProductPricesRequestPriceUsageType `json:"-" url:"price_usage_type,omitempty"`
	// Filter products that are not linked to any plan
	WithoutLinkedToPlan *bool `json:"-" url:"without_linked_to_plan,omitempty"`
	// Filter products that are one time charges
	WithOneTimeCharges *bool `json:"-" url:"with_one_time_charges,omitempty"`
	// Filter products that have zero price for free subscription type
	WithZeroPrice *bool `json:"-" url:"with_zero_price,omitempty"`
	// Filter products that have prices
	WithPricesOnly *bool `json:"-" url:"with_prices_only,omitempty"`
	// Filter products that are active
	IsActive *bool `json:"-" url:"is_active,omitempty"`
	// Page limit (default 100)
	Limit *int `json:"-" url:"limit,omitempty"`
	// Page offset (default 0)
	Offset *int `json:"-" url:"offset,omitempty"`
}

type SearchBillingPricesRequest struct {
	// Filter for prices valid for initial plans (free prices only)
	ForInitialPlan *bool `json:"-" url:"for_initial_plan,omitempty"`
	// Filter for prices valid for trial expiry plans (free prices only)
	ForTrialExpiryPlan *bool     `json:"-" url:"for_trial_expiry_plan,omitempty"`
	IDs                []*string `json:"-" url:"ids,omitempty"`
	ProductID          *string   `json:"-" url:"product_id,omitempty"`
	Interval           *string   `json:"-" url:"interval,omitempty"`
	Price              *int      `json:"-" url:"price,omitempty"`
	Q                  *string   `json:"-" url:"q,omitempty"`
	// Filter for prices that require a payment method (inverse of ForInitialPlan)
	RequiresPaymentMethod *bool                                `json:"-" url:"requires_payment_method,omitempty"`
	TiersMode             *SearchBillingPricesRequestTiersMode `json:"-" url:"tiers_mode,omitempty"`
	UsageType             *SearchBillingPricesRequestUsageType `json:"-" url:"usage_type,omitempty"`
	// Page limit (default 100)
	Limit *int `json:"-" url:"limit,omitempty"`
	// Page offset (default 0)
	Offset *int `json:"-" url:"offset,omitempty"`
}

type BillingCouponResponseData struct {
	AccountID        string                 `json:"account_id" url:"account_id"`
	AmountOff        *int                   `json:"amount_off,omitempty" url:"amount_off,omitempty"`
	Currency         *string                `json:"currency,omitempty" url:"currency,omitempty"`
	Duration         *string                `json:"duration,omitempty" url:"duration,omitempty"`
	DurationInMonths *int                   `json:"duration_in_months,omitempty" url:"duration_in_months,omitempty"`
	EnvironmentID    string                 `json:"environment_id" url:"environment_id"`
	ExternalID       string                 `json:"external_id" url:"external_id"`
	ID               string                 `json:"id" url:"id"`
	IsActive         bool                   `json:"is_active" url:"is_active"`
	MaxRedemptions   *int                   `json:"max_redemptions,omitempty" url:"max_redemptions,omitempty"`
	Metadata         map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	Name             string                 `json:"name" url:"name"`
	PercentOff       *float64               `json:"percent_off,omitempty" url:"percent_off,omitempty"`
	TimesRedeemed    int                    `json:"times_redeemed" url:"times_redeemed"`
	ValidFrom        *time.Time             `json:"valid_from,omitempty" url:"valid_from,omitempty"`
	ValidUntil       *time.Time             `json:"valid_until,omitempty" url:"valid_until,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BillingCouponResponseData) GetAccountID() string {
	if b == nil {
		return ""
	}
	return b.AccountID
}

func (b *BillingCouponResponseData) GetAmountOff() *int {
	if b == nil {
		return nil
	}
	return b.AmountOff
}

func (b *BillingCouponResponseData) GetCurrency() *string {
	if b == nil {
		return nil
	}
	return b.Currency
}

func (b *BillingCouponResponseData) GetDuration() *string {
	if b == nil {
		return nil
	}
	return b.Duration
}

func (b *BillingCouponResponseData) GetDurationInMonths() *int {
	if b == nil {
		return nil
	}
	return b.DurationInMonths
}

func (b *BillingCouponResponseData) GetEnvironmentID() string {
	if b == nil {
		return ""
	}
	return b.EnvironmentID
}

func (b *BillingCouponResponseData) GetExternalID() string {
	if b == nil {
		return ""
	}
	return b.ExternalID
}

func (b *BillingCouponResponseData) GetID() string {
	if b == nil {
		return ""
	}
	return b.ID
}

func (b *BillingCouponResponseData) GetIsActive() bool {
	if b == nil {
		return false
	}
	return b.IsActive
}

func (b *BillingCouponResponseData) GetMaxRedemptions() *int {
	if b == nil {
		return nil
	}
	return b.MaxRedemptions
}

func (b *BillingCouponResponseData) GetMetadata() map[string]interface{} {
	if b == nil {
		return nil
	}
	return b.Metadata
}

func (b *BillingCouponResponseData) GetName() string {
	if b == nil {
		return ""
	}
	return b.Name
}

func (b *BillingCouponResponseData) GetPercentOff() *float64 {
	if b == nil {
		return nil
	}
	return b.PercentOff
}

func (b *BillingCouponResponseData) GetTimesRedeemed() int {
	if b == nil {
		return 0
	}
	return b.TimesRedeemed
}

func (b *BillingCouponResponseData) GetValidFrom() *time.Time {
	if b == nil {
		return nil
	}
	return b.ValidFrom
}

func (b *BillingCouponResponseData) GetValidUntil() *time.Time {
	if b == nil {
		return nil
	}
	return b.ValidUntil
}

func (b *BillingCouponResponseData) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BillingCouponResponseData) UnmarshalJSON(data []byte) error {
	type embed BillingCouponResponseData
	var unmarshaler = struct {
		embed
		ValidFrom  *internal.DateTime `json:"valid_from,omitempty"`
		ValidUntil *internal.DateTime `json:"valid_until,omitempty"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BillingCouponResponseData(unmarshaler.embed)
	b.ValidFrom = unmarshaler.ValidFrom.TimePtr()
	b.ValidUntil = unmarshaler.ValidUntil.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BillingCouponResponseData) MarshalJSON() ([]byte, error) {
	type embed BillingCouponResponseData
	var marshaler = struct {
		embed
		ValidFrom  *internal.DateTime `json:"valid_from,omitempty"`
		ValidUntil *internal.DateTime `json:"valid_until,omitempty"`
	}{
		embed:      embed(*b),
		ValidFrom:  internal.NewOptionalDateTime(b.ValidFrom),
		ValidUntil: internal.NewOptionalDateTime(b.ValidUntil),
	}
	return json.Marshal(marshaler)
}

func (b *BillingCouponResponseData) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BillingCustomerResponseData struct {
	CompanyID      *string    `json:"company_id,omitempty" url:"company_id,omitempty"`
	DeletedAt      *time.Time `json:"deleted_at,omitempty" url:"deleted_at,omitempty"`
	Email          string     `json:"email" url:"email"`
	ExternalID     string     `json:"external_id" url:"external_id"`
	FailedToImport bool       `json:"failed_to_import" url:"failed_to_import"`
	ID             string     `json:"id" url:"id"`
	Name           string     `json:"name" url:"name"`
	UpdatedAt      time.Time  `json:"updated_at" url:"updated_at"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BillingCustomerResponseData) GetCompanyID() *string {
	if b == nil {
		return nil
	}
	return b.CompanyID
}

func (b *BillingCustomerResponseData) GetDeletedAt() *time.Time {
	if b == nil {
		return nil
	}
	return b.DeletedAt
}

func (b *BillingCustomerResponseData) GetEmail() string {
	if b == nil {
		return ""
	}
	return b.Email
}

func (b *BillingCustomerResponseData) GetExternalID() string {
	if b == nil {
		return ""
	}
	return b.ExternalID
}

func (b *BillingCustomerResponseData) GetFailedToImport() bool {
	if b == nil {
		return false
	}
	return b.FailedToImport
}

func (b *BillingCustomerResponseData) GetID() string {
	if b == nil {
		return ""
	}
	return b.ID
}

func (b *BillingCustomerResponseData) GetName() string {
	if b == nil {
		return ""
	}
	return b.Name
}

func (b *BillingCustomerResponseData) GetUpdatedAt() time.Time {
	if b == nil {
		return time.Time{}
	}
	return b.UpdatedAt
}

func (b *BillingCustomerResponseData) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BillingCustomerResponseData) UnmarshalJSON(data []byte) error {
	type embed BillingCustomerResponseData
	var unmarshaler = struct {
		embed
		DeletedAt *internal.DateTime `json:"deleted_at,omitempty"`
		UpdatedAt *internal.DateTime `json:"updated_at"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BillingCustomerResponseData(unmarshaler.embed)
	b.DeletedAt = unmarshaler.DeletedAt.TimePtr()
	b.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BillingCustomerResponseData) MarshalJSON() ([]byte, error) {
	type embed BillingCustomerResponseData
	var marshaler = struct {
		embed
		DeletedAt *internal.DateTime `json:"deleted_at,omitempty"`
		UpdatedAt *internal.DateTime `json:"updated_at"`
	}{
		embed:     embed(*b),
		DeletedAt: internal.NewOptionalDateTime(b.DeletedAt),
		UpdatedAt: internal.NewDateTime(b.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (b *BillingCustomerResponseData) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BillingCustomerSubscription struct {
	Currency     string     `json:"currency" url:"currency"`
	ExpiredAt    *time.Time `json:"expired_at,omitempty" url:"expired_at,omitempty"`
	Interval     string     `json:"interval" url:"interval"`
	MeteredUsage bool       `json:"metered_usage" url:"metered_usage"`
	PerUnitPrice int        `json:"per_unit_price" url:"per_unit_price"`
	TotalPrice   int        `json:"total_price" url:"total_price"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BillingCustomerSubscription) GetCurrency() string {
	if b == nil {
		return ""
	}
	return b.Currency
}

func (b *BillingCustomerSubscription) GetExpiredAt() *time.Time {
	if b == nil {
		return nil
	}
	return b.ExpiredAt
}

func (b *BillingCustomerSubscription) GetInterval() string {
	if b == nil {
		return ""
	}
	return b.Interval
}

func (b *BillingCustomerSubscription) GetMeteredUsage() bool {
	if b == nil {
		return false
	}
	return b.MeteredUsage
}

func (b *BillingCustomerSubscription) GetPerUnitPrice() int {
	if b == nil {
		return 0
	}
	return b.PerUnitPrice
}

func (b *BillingCustomerSubscription) GetTotalPrice() int {
	if b == nil {
		return 0
	}
	return b.TotalPrice
}

func (b *BillingCustomerSubscription) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BillingCustomerSubscription) UnmarshalJSON(data []byte) error {
	type embed BillingCustomerSubscription
	var unmarshaler = struct {
		embed
		ExpiredAt *internal.DateTime `json:"expired_at,omitempty"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BillingCustomerSubscription(unmarshaler.embed)
	b.ExpiredAt = unmarshaler.ExpiredAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BillingCustomerSubscription) MarshalJSON() ([]byte, error) {
	type embed BillingCustomerSubscription
	var marshaler = struct {
		embed
		ExpiredAt *internal.DateTime `json:"expired_at,omitempty"`
	}{
		embed:     embed(*b),
		ExpiredAt: internal.NewOptionalDateTime(b.ExpiredAt),
	}
	return json.Marshal(marshaler)
}

func (b *BillingCustomerSubscription) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BillingCustomerWithSubscriptionsResponseData struct {
	CompanyID      *string                        `json:"company_id,omitempty" url:"company_id,omitempty"`
	DeletedAt      *time.Time                     `json:"deleted_at,omitempty" url:"deleted_at,omitempty"`
	Email          string                         `json:"email" url:"email"`
	ExternalID     string                         `json:"external_id" url:"external_id"`
	FailedToImport bool                           `json:"failed_to_import" url:"failed_to_import"`
	ID             string                         `json:"id" url:"id"`
	Name           string                         `json:"name" url:"name"`
	Subscriptions  []*BillingCustomerSubscription `json:"subscriptions,omitempty" url:"subscriptions,omitempty"`
	UpdatedAt      time.Time                      `json:"updated_at" url:"updated_at"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BillingCustomerWithSubscriptionsResponseData) GetCompanyID() *string {
	if b == nil {
		return nil
	}
	return b.CompanyID
}

func (b *BillingCustomerWithSubscriptionsResponseData) GetDeletedAt() *time.Time {
	if b == nil {
		return nil
	}
	return b.DeletedAt
}

func (b *BillingCustomerWithSubscriptionsResponseData) GetEmail() string {
	if b == nil {
		return ""
	}
	return b.Email
}

func (b *BillingCustomerWithSubscriptionsResponseData) GetExternalID() string {
	if b == nil {
		return ""
	}
	return b.ExternalID
}

func (b *BillingCustomerWithSubscriptionsResponseData) GetFailedToImport() bool {
	if b == nil {
		return false
	}
	return b.FailedToImport
}

func (b *BillingCustomerWithSubscriptionsResponseData) GetID() string {
	if b == nil {
		return ""
	}
	return b.ID
}

func (b *BillingCustomerWithSubscriptionsResponseData) GetName() string {
	if b == nil {
		return ""
	}
	return b.Name
}

func (b *BillingCustomerWithSubscriptionsResponseData) GetSubscriptions() []*BillingCustomerSubscription {
	if b == nil {
		return nil
	}
	return b.Subscriptions
}

func (b *BillingCustomerWithSubscriptionsResponseData) GetUpdatedAt() time.Time {
	if b == nil {
		return time.Time{}
	}
	return b.UpdatedAt
}

func (b *BillingCustomerWithSubscriptionsResponseData) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BillingCustomerWithSubscriptionsResponseData) UnmarshalJSON(data []byte) error {
	type embed BillingCustomerWithSubscriptionsResponseData
	var unmarshaler = struct {
		embed
		DeletedAt *internal.DateTime `json:"deleted_at,omitempty"`
		UpdatedAt *internal.DateTime `json:"updated_at"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BillingCustomerWithSubscriptionsResponseData(unmarshaler.embed)
	b.DeletedAt = unmarshaler.DeletedAt.TimePtr()
	b.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BillingCustomerWithSubscriptionsResponseData) MarshalJSON() ([]byte, error) {
	type embed BillingCustomerWithSubscriptionsResponseData
	var marshaler = struct {
		embed
		DeletedAt *internal.DateTime `json:"deleted_at,omitempty"`
		UpdatedAt *internal.DateTime `json:"updated_at"`
	}{
		embed:     embed(*b),
		DeletedAt: internal.NewOptionalDateTime(b.DeletedAt),
		UpdatedAt: internal.NewDateTime(b.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (b *BillingCustomerWithSubscriptionsResponseData) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BillingMeterResponseData struct {
	DispalyName     string `json:"dispaly_name" url:"dispaly_name"`
	EventName       string `json:"event_name" url:"event_name"`
	EventPayloadKey string `json:"event_payload_key" url:"event_payload_key"`
	ExternalPriceID string `json:"external_price_id" url:"external_price_id"`
	ID              string `json:"id" url:"id"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BillingMeterResponseData) GetDispalyName() string {
	if b == nil {
		return ""
	}
	return b.DispalyName
}

func (b *BillingMeterResponseData) GetEventName() string {
	if b == nil {
		return ""
	}
	return b.EventName
}

func (b *BillingMeterResponseData) GetEventPayloadKey() string {
	if b == nil {
		return ""
	}
	return b.EventPayloadKey
}

func (b *BillingMeterResponseData) GetExternalPriceID() string {
	if b == nil {
		return ""
	}
	return b.ExternalPriceID
}

func (b *BillingMeterResponseData) GetID() string {
	if b == nil {
		return ""
	}
	return b.ID
}

func (b *BillingMeterResponseData) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BillingMeterResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler BillingMeterResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BillingMeterResponseData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BillingMeterResponseData) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BillingProductPricing struct {
	BillingThreshold           *int                           `json:"billing_threshold,omitempty" url:"billing_threshold,omitempty"`
	Currency                   string                         `json:"currency" url:"currency"`
	Interval                   string                         `json:"interval" url:"interval"`
	MeterID                    *string                        `json:"meter_id,omitempty" url:"meter_id,omitempty"`
	PackageSize                *int                           `json:"package_size,omitempty" url:"package_size,omitempty"`
	Price                      int                            `json:"price" url:"price"`
	PriceDecimal               *string                        `json:"price_decimal,omitempty" url:"price_decimal,omitempty"`
	PriceExternalID            string                         `json:"price_external_id" url:"price_external_id"`
	ProductExternalID          string                         `json:"product_external_id" url:"product_external_id"`
	Quantity                   int                            `json:"quantity" url:"quantity"`
	SubscriptionItemExternalID *string                        `json:"subscription_item_external_id,omitempty" url:"subscription_item_external_id,omitempty"`
	UsageType                  BillingProductPricingUsageType `json:"usage_type" url:"usage_type"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BillingProductPricing) GetBillingThreshold() *int {
	if b == nil {
		return nil
	}
	return b.BillingThreshold
}

func (b *BillingProductPricing) GetCurrency() string {
	if b == nil {
		return ""
	}
	return b.Currency
}

func (b *BillingProductPricing) GetInterval() string {
	if b == nil {
		return ""
	}
	return b.Interval
}

func (b *BillingProductPricing) GetMeterID() *string {
	if b == nil {
		return nil
	}
	return b.MeterID
}

func (b *BillingProductPricing) GetPackageSize() *int {
	if b == nil {
		return nil
	}
	return b.PackageSize
}

func (b *BillingProductPricing) GetPrice() int {
	if b == nil {
		return 0
	}
	return b.Price
}

func (b *BillingProductPricing) GetPriceDecimal() *string {
	if b == nil {
		return nil
	}
	return b.PriceDecimal
}

func (b *BillingProductPricing) GetPriceExternalID() string {
	if b == nil {
		return ""
	}
	return b.PriceExternalID
}

func (b *BillingProductPricing) GetProductExternalID() string {
	if b == nil {
		return ""
	}
	return b.ProductExternalID
}

func (b *BillingProductPricing) GetQuantity() int {
	if b == nil {
		return 0
	}
	return b.Quantity
}

func (b *BillingProductPricing) GetSubscriptionItemExternalID() *string {
	if b == nil {
		return nil
	}
	return b.SubscriptionItemExternalID
}

func (b *BillingProductPricing) GetUsageType() BillingProductPricingUsageType {
	if b == nil {
		return ""
	}
	return b.UsageType
}

func (b *BillingProductPricing) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BillingProductPricing) UnmarshalJSON(data []byte) error {
	type unmarshaler BillingProductPricing
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BillingProductPricing(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BillingProductPricing) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BillingProductPricingUsageType string

const (
	BillingProductPricingUsageTypeLicensed BillingProductPricingUsageType = "licensed"
	BillingProductPricingUsageTypeMetered  BillingProductPricingUsageType = "metered"
)

func NewBillingProductPricingUsageTypeFromString(s string) (BillingProductPricingUsageType, error) {
	switch s {
	case "licensed":
		return BillingProductPricingUsageTypeLicensed, nil
	case "metered":
		return BillingProductPricingUsageTypeMetered, nil
	}
	var t BillingProductPricingUsageType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BillingProductPricingUsageType) Ptr() *BillingProductPricingUsageType {
	return &b
}

type BillingSubscriptionDiscount struct {
	CouponExternalID    string     `json:"coupon_external_id" url:"coupon_external_id"`
	CustomerFacingCode  *string    `json:"customer_facing_code,omitempty" url:"customer_facing_code,omitempty"`
	EndedAt             *time.Time `json:"ended_at,omitempty" url:"ended_at,omitempty"`
	ExternalID          string     `json:"external_id" url:"external_id"`
	IsActive            bool       `json:"is_active" url:"is_active"`
	PromoCodeExternalID *string    `json:"promo_code_external_id,omitempty" url:"promo_code_external_id,omitempty"`
	StartedAt           time.Time  `json:"started_at" url:"started_at"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BillingSubscriptionDiscount) GetCouponExternalID() string {
	if b == nil {
		return ""
	}
	return b.CouponExternalID
}

func (b *BillingSubscriptionDiscount) GetCustomerFacingCode() *string {
	if b == nil {
		return nil
	}
	return b.CustomerFacingCode
}

func (b *BillingSubscriptionDiscount) GetEndedAt() *time.Time {
	if b == nil {
		return nil
	}
	return b.EndedAt
}

func (b *BillingSubscriptionDiscount) GetExternalID() string {
	if b == nil {
		return ""
	}
	return b.ExternalID
}

func (b *BillingSubscriptionDiscount) GetIsActive() bool {
	if b == nil {
		return false
	}
	return b.IsActive
}

func (b *BillingSubscriptionDiscount) GetPromoCodeExternalID() *string {
	if b == nil {
		return nil
	}
	return b.PromoCodeExternalID
}

func (b *BillingSubscriptionDiscount) GetStartedAt() time.Time {
	if b == nil {
		return time.Time{}
	}
	return b.StartedAt
}

func (b *BillingSubscriptionDiscount) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BillingSubscriptionDiscount) UnmarshalJSON(data []byte) error {
	type embed BillingSubscriptionDiscount
	var unmarshaler = struct {
		embed
		EndedAt   *internal.DateTime `json:"ended_at,omitempty"`
		StartedAt *internal.DateTime `json:"started_at"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BillingSubscriptionDiscount(unmarshaler.embed)
	b.EndedAt = unmarshaler.EndedAt.TimePtr()
	b.StartedAt = unmarshaler.StartedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BillingSubscriptionDiscount) MarshalJSON() ([]byte, error) {
	type embed BillingSubscriptionDiscount
	var marshaler = struct {
		embed
		EndedAt   *internal.DateTime `json:"ended_at,omitempty"`
		StartedAt *internal.DateTime `json:"started_at"`
	}{
		embed:     embed(*b),
		EndedAt:   internal.NewOptionalDateTime(b.EndedAt),
		StartedAt: internal.NewDateTime(b.StartedAt),
	}
	return json.Marshal(marshaler)
}

func (b *BillingSubscriptionDiscount) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type CreateBillingPriceTierRequestBody struct {
	FlatAmount      *int    `json:"flat_amount,omitempty" url:"flat_amount,omitempty"`
	PerUnitDecimal  *string `json:"per_unit_decimal,omitempty" url:"per_unit_decimal,omitempty"`
	PerUnitPrice    *int    `json:"per_unit_price,omitempty" url:"per_unit_price,omitempty"`
	PriceExternalID string  `json:"price_external_id" url:"price_external_id"`
	UpTo            *int    `json:"up_to,omitempty" url:"up_to,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateBillingPriceTierRequestBody) GetFlatAmount() *int {
	if c == nil {
		return nil
	}
	return c.FlatAmount
}

func (c *CreateBillingPriceTierRequestBody) GetPerUnitDecimal() *string {
	if c == nil {
		return nil
	}
	return c.PerUnitDecimal
}

func (c *CreateBillingPriceTierRequestBody) GetPerUnitPrice() *int {
	if c == nil {
		return nil
	}
	return c.PerUnitPrice
}

func (c *CreateBillingPriceTierRequestBody) GetPriceExternalID() string {
	if c == nil {
		return ""
	}
	return c.PriceExternalID
}

func (c *CreateBillingPriceTierRequestBody) GetUpTo() *int {
	if c == nil {
		return nil
	}
	return c.UpTo
}

func (c *CreateBillingPriceTierRequestBody) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateBillingPriceTierRequestBody) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateBillingPriceTierRequestBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateBillingPriceTierRequestBody(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateBillingPriceTierRequestBody) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Input parameters
type CountBillingProductsParams struct {
	IDs []string `json:"ids,omitempty" url:"ids,omitempty"`
	// Filter products that are active
	IsActive *bool `json:"is_active,omitempty" url:"is_active,omitempty"`
	// Page limit (default 100)
	Limit *int    `json:"limit,omitempty" url:"limit,omitempty"`
	Name  *string `json:"name,omitempty" url:"name,omitempty"`
	// Page offset (default 0)
	Offset         *int                                              `json:"offset,omitempty" url:"offset,omitempty"`
	PriceUsageType *CountBillingProductsResponseParamsPriceUsageType `json:"price_usage_type,omitempty" url:"price_usage_type,omitempty"`
	Q              *string                                           `json:"q,omitempty" url:"q,omitempty"`
	// Filter products that are one time charges
	WithOneTimeCharges *bool `json:"with_one_time_charges,omitempty" url:"with_one_time_charges,omitempty"`
	// Filter products that have prices
	WithPricesOnly *bool `json:"with_prices_only,omitempty" url:"with_prices_only,omitempty"`
	// Filter products that have zero price for free subscription type
	WithZeroPrice *bool `json:"with_zero_price,omitempty" url:"with_zero_price,omitempty"`
	// Filter products that are not linked to any plan
	WithoutLinkedToPlan *bool `json:"without_linked_to_plan,omitempty" url:"without_linked_to_plan,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CountBillingProductsParams) GetIDs() []string {
	if c == nil {
		return nil
	}
	return c.IDs
}

func (c *CountBillingProductsParams) GetIsActive() *bool {
	if c == nil {
		return nil
	}
	return c.IsActive
}

func (c *CountBillingProductsParams) GetLimit() *int {
	if c == nil {
		return nil
	}
	return c.Limit
}

func (c *CountBillingProductsParams) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CountBillingProductsParams) GetOffset() *int {
	if c == nil {
		return nil
	}
	return c.Offset
}

func (c *CountBillingProductsParams) GetPriceUsageType() *CountBillingProductsResponseParamsPriceUsageType {
	if c == nil {
		return nil
	}
	return c.PriceUsageType
}

func (c *CountBillingProductsParams) GetQ() *string {
	if c == nil {
		return nil
	}
	return c.Q
}

func (c *CountBillingProductsParams) GetWithOneTimeCharges() *bool {
	if c == nil {
		return nil
	}
	return c.WithOneTimeCharges
}

func (c *CountBillingProductsParams) GetWithPricesOnly() *bool {
	if c == nil {
		return nil
	}
	return c.WithPricesOnly
}

func (c *CountBillingProductsParams) GetWithZeroPrice() *bool {
	if c == nil {
		return nil
	}
	return c.WithZeroPrice
}

func (c *CountBillingProductsParams) GetWithoutLinkedToPlan() *bool {
	if c == nil {
		return nil
	}
	return c.WithoutLinkedToPlan
}

func (c *CountBillingProductsParams) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CountBillingProductsParams) UnmarshalJSON(data []byte) error {
	type unmarshaler CountBillingProductsParams
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CountBillingProductsParams(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CountBillingProductsParams) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CountBillingProductsRequestPriceUsageType string

const (
	CountBillingProductsRequestPriceUsageTypeLicensed CountBillingProductsRequestPriceUsageType = "licensed"
	CountBillingProductsRequestPriceUsageTypeMetered  CountBillingProductsRequestPriceUsageType = "metered"
)

func NewCountBillingProductsRequestPriceUsageTypeFromString(s string) (CountBillingProductsRequestPriceUsageType, error) {
	switch s {
	case "licensed":
		return CountBillingProductsRequestPriceUsageTypeLicensed, nil
	case "metered":
		return CountBillingProductsRequestPriceUsageTypeMetered, nil
	}
	var t CountBillingProductsRequestPriceUsageType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CountBillingProductsRequestPriceUsageType) Ptr() *CountBillingProductsRequestPriceUsageType {
	return &c
}

type CountBillingProductsResponse struct {
	Data *CountResponse `json:"data,omitempty" url:"data,omitempty"`
	// Input parameters
	Params *CountBillingProductsParams `json:"params,omitempty" url:"params,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CountBillingProductsResponse) GetData() *CountResponse {
	if c == nil {
		return nil
	}
	return c.Data
}

func (c *CountBillingProductsResponse) GetParams() *CountBillingProductsParams {
	if c == nil {
		return nil
	}
	return c.Params
}

func (c *CountBillingProductsResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CountBillingProductsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CountBillingProductsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CountBillingProductsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CountBillingProductsResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CountBillingProductsResponseParamsPriceUsageType string

const (
	CountBillingProductsResponseParamsPriceUsageTypeLicensed CountBillingProductsResponseParamsPriceUsageType = "licensed"
	CountBillingProductsResponseParamsPriceUsageTypeMetered  CountBillingProductsResponseParamsPriceUsageType = "metered"
)

func NewCountBillingProductsResponseParamsPriceUsageTypeFromString(s string) (CountBillingProductsResponseParamsPriceUsageType, error) {
	switch s {
	case "licensed":
		return CountBillingProductsResponseParamsPriceUsageTypeLicensed, nil
	case "metered":
		return CountBillingProductsResponseParamsPriceUsageTypeMetered, nil
	}
	var t CountBillingProductsResponseParamsPriceUsageType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CountBillingProductsResponseParamsPriceUsageType) Ptr() *CountBillingProductsResponseParamsPriceUsageType {
	return &c
}

// Input parameters
type CountCustomersParams struct {
	CompanyIDs     []string `json:"company_ids,omitempty" url:"company_ids,omitempty"`
	FailedToImport *bool    `json:"failed_to_import,omitempty" url:"failed_to_import,omitempty"`
	// Page limit (default 100)
	Limit *int    `json:"limit,omitempty" url:"limit,omitempty"`
	Name  *string `json:"name,omitempty" url:"name,omitempty"`
	// Page offset (default 0)
	Offset *int    `json:"offset,omitempty" url:"offset,omitempty"`
	Q      *string `json:"q,omitempty" url:"q,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CountCustomersParams) GetCompanyIDs() []string {
	if c == nil {
		return nil
	}
	return c.CompanyIDs
}

func (c *CountCustomersParams) GetFailedToImport() *bool {
	if c == nil {
		return nil
	}
	return c.FailedToImport
}

func (c *CountCustomersParams) GetLimit() *int {
	if c == nil {
		return nil
	}
	return c.Limit
}

func (c *CountCustomersParams) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CountCustomersParams) GetOffset() *int {
	if c == nil {
		return nil
	}
	return c.Offset
}

func (c *CountCustomersParams) GetQ() *string {
	if c == nil {
		return nil
	}
	return c.Q
}

func (c *CountCustomersParams) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CountCustomersParams) UnmarshalJSON(data []byte) error {
	type unmarshaler CountCustomersParams
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CountCustomersParams(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CountCustomersParams) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CountCustomersResponse struct {
	Data *CountResponse `json:"data,omitempty" url:"data,omitempty"`
	// Input parameters
	Params *CountCustomersParams `json:"params,omitempty" url:"params,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CountCustomersResponse) GetData() *CountResponse {
	if c == nil {
		return nil
	}
	return c.Data
}

func (c *CountCustomersResponse) GetParams() *CountCustomersParams {
	if c == nil {
		return nil
	}
	return c.Params
}

func (c *CountCustomersResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CountCustomersResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CountCustomersResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CountCustomersResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CountCustomersResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateBillingPriceRequestBodyBillingScheme string

const (
	CreateBillingPriceRequestBodyBillingSchemePerUnit CreateBillingPriceRequestBodyBillingScheme = "per_unit"
	CreateBillingPriceRequestBodyBillingSchemeTiered  CreateBillingPriceRequestBodyBillingScheme = "tiered"
)

func NewCreateBillingPriceRequestBodyBillingSchemeFromString(s string) (CreateBillingPriceRequestBodyBillingScheme, error) {
	switch s {
	case "per_unit":
		return CreateBillingPriceRequestBodyBillingSchemePerUnit, nil
	case "tiered":
		return CreateBillingPriceRequestBodyBillingSchemeTiered, nil
	}
	var t CreateBillingPriceRequestBodyBillingScheme
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateBillingPriceRequestBodyBillingScheme) Ptr() *CreateBillingPriceRequestBodyBillingScheme {
	return &c
}

type CreateBillingPriceRequestBodyTiersMode string

const (
	CreateBillingPriceRequestBodyTiersModeVolume    CreateBillingPriceRequestBodyTiersMode = "volume"
	CreateBillingPriceRequestBodyTiersModeGraduated CreateBillingPriceRequestBodyTiersMode = "graduated"
)

func NewCreateBillingPriceRequestBodyTiersModeFromString(s string) (CreateBillingPriceRequestBodyTiersMode, error) {
	switch s {
	case "volume":
		return CreateBillingPriceRequestBodyTiersModeVolume, nil
	case "graduated":
		return CreateBillingPriceRequestBodyTiersModeGraduated, nil
	}
	var t CreateBillingPriceRequestBodyTiersMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateBillingPriceRequestBodyTiersMode) Ptr() *CreateBillingPriceRequestBodyTiersMode {
	return &c
}

type CreateBillingPriceRequestBodyUsageType string

const (
	CreateBillingPriceRequestBodyUsageTypeLicensed CreateBillingPriceRequestBodyUsageType = "licensed"
	CreateBillingPriceRequestBodyUsageTypeMetered  CreateBillingPriceRequestBodyUsageType = "metered"
)

func NewCreateBillingPriceRequestBodyUsageTypeFromString(s string) (CreateBillingPriceRequestBodyUsageType, error) {
	switch s {
	case "licensed":
		return CreateBillingPriceRequestBodyUsageTypeLicensed, nil
	case "metered":
		return CreateBillingPriceRequestBodyUsageTypeMetered, nil
	}
	var t CreateBillingPriceRequestBodyUsageType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateBillingPriceRequestBodyUsageType) Ptr() *CreateBillingPriceRequestBodyUsageType {
	return &c
}

type CreateBillingSubscriptionRequestBodyTrialEndSetting string

const (
	CreateBillingSubscriptionRequestBodyTrialEndSettingSubscribe CreateBillingSubscriptionRequestBodyTrialEndSetting = "subscribe"
	CreateBillingSubscriptionRequestBodyTrialEndSettingCancel    CreateBillingSubscriptionRequestBodyTrialEndSetting = "cancel"
)

func NewCreateBillingSubscriptionRequestBodyTrialEndSettingFromString(s string) (CreateBillingSubscriptionRequestBodyTrialEndSetting, error) {
	switch s {
	case "subscribe":
		return CreateBillingSubscriptionRequestBodyTrialEndSettingSubscribe, nil
	case "cancel":
		return CreateBillingSubscriptionRequestBodyTrialEndSettingCancel, nil
	}
	var t CreateBillingSubscriptionRequestBodyTrialEndSetting
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateBillingSubscriptionRequestBodyTrialEndSetting) Ptr() *CreateBillingSubscriptionRequestBodyTrialEndSetting {
	return &c
}

type DeleteBillingProductResponse struct {
	Data *DeleteResponse `json:"data,omitempty" url:"data,omitempty"`
	// Input parameters
	Params map[string]interface{} `json:"params,omitempty" url:"params,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeleteBillingProductResponse) GetData() *DeleteResponse {
	if d == nil {
		return nil
	}
	return d.Data
}

func (d *DeleteBillingProductResponse) GetParams() map[string]interface{} {
	if d == nil {
		return nil
	}
	return d.Params
}

func (d *DeleteBillingProductResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteBillingProductResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteBillingProductResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteBillingProductResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteBillingProductResponse) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteProductPriceResponse struct {
	Data *DeleteResponse `json:"data,omitempty" url:"data,omitempty"`
	// Input parameters
	Params map[string]interface{} `json:"params,omitempty" url:"params,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeleteProductPriceResponse) GetData() *DeleteResponse {
	if d == nil {
		return nil
	}
	return d.Data
}

func (d *DeleteProductPriceResponse) GetParams() map[string]interface{} {
	if d == nil {
		return nil
	}
	return d.Params
}

func (d *DeleteProductPriceResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteProductPriceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteProductPriceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteProductPriceResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteProductPriceResponse) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Input parameters
type ListBillingProductsParams struct {
	IDs []string `json:"ids,omitempty" url:"ids,omitempty"`
	// Filter products that are active
	IsActive *bool `json:"is_active,omitempty" url:"is_active,omitempty"`
	// Page limit (default 100)
	Limit *int    `json:"limit,omitempty" url:"limit,omitempty"`
	Name  *string `json:"name,omitempty" url:"name,omitempty"`
	// Page offset (default 0)
	Offset         *int                                             `json:"offset,omitempty" url:"offset,omitempty"`
	PriceUsageType *ListBillingProductsResponseParamsPriceUsageType `json:"price_usage_type,omitempty" url:"price_usage_type,omitempty"`
	Q              *string                                          `json:"q,omitempty" url:"q,omitempty"`
	// Filter products that are one time charges
	WithOneTimeCharges *bool `json:"with_one_time_charges,omitempty" url:"with_one_time_charges,omitempty"`
	// Filter products that have prices
	WithPricesOnly *bool `json:"with_prices_only,omitempty" url:"with_prices_only,omitempty"`
	// Filter products that have zero price for free subscription type
	WithZeroPrice *bool `json:"with_zero_price,omitempty" url:"with_zero_price,omitempty"`
	// Filter products that are not linked to any plan
	WithoutLinkedToPlan *bool `json:"without_linked_to_plan,omitempty" url:"without_linked_to_plan,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListBillingProductsParams) GetIDs() []string {
	if l == nil {
		return nil
	}
	return l.IDs
}

func (l *ListBillingProductsParams) GetIsActive() *bool {
	if l == nil {
		return nil
	}
	return l.IsActive
}

func (l *ListBillingProductsParams) GetLimit() *int {
	if l == nil {
		return nil
	}
	return l.Limit
}

func (l *ListBillingProductsParams) GetName() *string {
	if l == nil {
		return nil
	}
	return l.Name
}

func (l *ListBillingProductsParams) GetOffset() *int {
	if l == nil {
		return nil
	}
	return l.Offset
}

func (l *ListBillingProductsParams) GetPriceUsageType() *ListBillingProductsResponseParamsPriceUsageType {
	if l == nil {
		return nil
	}
	return l.PriceUsageType
}

func (l *ListBillingProductsParams) GetQ() *string {
	if l == nil {
		return nil
	}
	return l.Q
}

func (l *ListBillingProductsParams) GetWithOneTimeCharges() *bool {
	if l == nil {
		return nil
	}
	return l.WithOneTimeCharges
}

func (l *ListBillingProductsParams) GetWithPricesOnly() *bool {
	if l == nil {
		return nil
	}
	return l.WithPricesOnly
}

func (l *ListBillingProductsParams) GetWithZeroPrice() *bool {
	if l == nil {
		return nil
	}
	return l.WithZeroPrice
}

func (l *ListBillingProductsParams) GetWithoutLinkedToPlan() *bool {
	if l == nil {
		return nil
	}
	return l.WithoutLinkedToPlan
}

func (l *ListBillingProductsParams) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListBillingProductsParams) UnmarshalJSON(data []byte) error {
	type unmarshaler ListBillingProductsParams
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListBillingProductsParams(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListBillingProductsParams) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListBillingProductsRequestPriceUsageType string

const (
	ListBillingProductsRequestPriceUsageTypeLicensed ListBillingProductsRequestPriceUsageType = "licensed"
	ListBillingProductsRequestPriceUsageTypeMetered  ListBillingProductsRequestPriceUsageType = "metered"
)

func NewListBillingProductsRequestPriceUsageTypeFromString(s string) (ListBillingProductsRequestPriceUsageType, error) {
	switch s {
	case "licensed":
		return ListBillingProductsRequestPriceUsageTypeLicensed, nil
	case "metered":
		return ListBillingProductsRequestPriceUsageTypeMetered, nil
	}
	var t ListBillingProductsRequestPriceUsageType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l ListBillingProductsRequestPriceUsageType) Ptr() *ListBillingProductsRequestPriceUsageType {
	return &l
}

type ListBillingProductsResponse struct {
	Data []*BillingProductDetailResponseData `json:"data,omitempty" url:"data,omitempty"`
	// Input parameters
	Params *ListBillingProductsParams `json:"params,omitempty" url:"params,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListBillingProductsResponse) GetData() []*BillingProductDetailResponseData {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *ListBillingProductsResponse) GetParams() *ListBillingProductsParams {
	if l == nil {
		return nil
	}
	return l.Params
}

func (l *ListBillingProductsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListBillingProductsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListBillingProductsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListBillingProductsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListBillingProductsResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListBillingProductsResponseParamsPriceUsageType string

const (
	ListBillingProductsResponseParamsPriceUsageTypeLicensed ListBillingProductsResponseParamsPriceUsageType = "licensed"
	ListBillingProductsResponseParamsPriceUsageTypeMetered  ListBillingProductsResponseParamsPriceUsageType = "metered"
)

func NewListBillingProductsResponseParamsPriceUsageTypeFromString(s string) (ListBillingProductsResponseParamsPriceUsageType, error) {
	switch s {
	case "licensed":
		return ListBillingProductsResponseParamsPriceUsageTypeLicensed, nil
	case "metered":
		return ListBillingProductsResponseParamsPriceUsageTypeMetered, nil
	}
	var t ListBillingProductsResponseParamsPriceUsageType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l ListBillingProductsResponseParamsPriceUsageType) Ptr() *ListBillingProductsResponseParamsPriceUsageType {
	return &l
}

// Input parameters
type ListCouponsParams struct {
	IsActive *bool `json:"is_active,omitempty" url:"is_active,omitempty"`
	// Page limit (default 100)
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// Page offset (default 0)
	Offset *int    `json:"offset,omitempty" url:"offset,omitempty"`
	Q      *string `json:"q,omitempty" url:"q,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListCouponsParams) GetIsActive() *bool {
	if l == nil {
		return nil
	}
	return l.IsActive
}

func (l *ListCouponsParams) GetLimit() *int {
	if l == nil {
		return nil
	}
	return l.Limit
}

func (l *ListCouponsParams) GetOffset() *int {
	if l == nil {
		return nil
	}
	return l.Offset
}

func (l *ListCouponsParams) GetQ() *string {
	if l == nil {
		return nil
	}
	return l.Q
}

func (l *ListCouponsParams) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListCouponsParams) UnmarshalJSON(data []byte) error {
	type unmarshaler ListCouponsParams
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListCouponsParams(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListCouponsParams) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListCouponsResponse struct {
	Data []*BillingCouponResponseData `json:"data,omitempty" url:"data,omitempty"`
	// Input parameters
	Params *ListCouponsParams `json:"params,omitempty" url:"params,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListCouponsResponse) GetData() []*BillingCouponResponseData {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *ListCouponsResponse) GetParams() *ListCouponsParams {
	if l == nil {
		return nil
	}
	return l.Params
}

func (l *ListCouponsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListCouponsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListCouponsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListCouponsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListCouponsResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Input parameters
type ListCustomersWithSubscriptionsParams struct {
	CompanyIDs     []string `json:"company_ids,omitempty" url:"company_ids,omitempty"`
	FailedToImport *bool    `json:"failed_to_import,omitempty" url:"failed_to_import,omitempty"`
	// Page limit (default 100)
	Limit *int    `json:"limit,omitempty" url:"limit,omitempty"`
	Name  *string `json:"name,omitempty" url:"name,omitempty"`
	// Page offset (default 0)
	Offset *int    `json:"offset,omitempty" url:"offset,omitempty"`
	Q      *string `json:"q,omitempty" url:"q,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListCustomersWithSubscriptionsParams) GetCompanyIDs() []string {
	if l == nil {
		return nil
	}
	return l.CompanyIDs
}

func (l *ListCustomersWithSubscriptionsParams) GetFailedToImport() *bool {
	if l == nil {
		return nil
	}
	return l.FailedToImport
}

func (l *ListCustomersWithSubscriptionsParams) GetLimit() *int {
	if l == nil {
		return nil
	}
	return l.Limit
}

func (l *ListCustomersWithSubscriptionsParams) GetName() *string {
	if l == nil {
		return nil
	}
	return l.Name
}

func (l *ListCustomersWithSubscriptionsParams) GetOffset() *int {
	if l == nil {
		return nil
	}
	return l.Offset
}

func (l *ListCustomersWithSubscriptionsParams) GetQ() *string {
	if l == nil {
		return nil
	}
	return l.Q
}

func (l *ListCustomersWithSubscriptionsParams) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListCustomersWithSubscriptionsParams) UnmarshalJSON(data []byte) error {
	type unmarshaler ListCustomersWithSubscriptionsParams
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListCustomersWithSubscriptionsParams(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListCustomersWithSubscriptionsParams) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListCustomersWithSubscriptionsResponse struct {
	Data []*BillingCustomerWithSubscriptionsResponseData `json:"data,omitempty" url:"data,omitempty"`
	// Input parameters
	Params *ListCustomersWithSubscriptionsParams `json:"params,omitempty" url:"params,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListCustomersWithSubscriptionsResponse) GetData() []*BillingCustomerWithSubscriptionsResponseData {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *ListCustomersWithSubscriptionsResponse) GetParams() *ListCustomersWithSubscriptionsParams {
	if l == nil {
		return nil
	}
	return l.Params
}

func (l *ListCustomersWithSubscriptionsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListCustomersWithSubscriptionsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListCustomersWithSubscriptionsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListCustomersWithSubscriptionsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListCustomersWithSubscriptionsResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Input parameters
type ListInvoicesParams struct {
	CompanyID          *string `json:"company_id,omitempty" url:"company_id,omitempty"`
	CustomerExternalID *string `json:"customer_external_id,omitempty" url:"customer_external_id,omitempty"`
	// Page limit (default 100)
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// Page offset (default 0)
	Offset                 *int    `json:"offset,omitempty" url:"offset,omitempty"`
	SubscriptionExternalID *string `json:"subscription_external_id,omitempty" url:"subscription_external_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListInvoicesParams) GetCompanyID() *string {
	if l == nil {
		return nil
	}
	return l.CompanyID
}

func (l *ListInvoicesParams) GetCustomerExternalID() *string {
	if l == nil {
		return nil
	}
	return l.CustomerExternalID
}

func (l *ListInvoicesParams) GetLimit() *int {
	if l == nil {
		return nil
	}
	return l.Limit
}

func (l *ListInvoicesParams) GetOffset() *int {
	if l == nil {
		return nil
	}
	return l.Offset
}

func (l *ListInvoicesParams) GetSubscriptionExternalID() *string {
	if l == nil {
		return nil
	}
	return l.SubscriptionExternalID
}

func (l *ListInvoicesParams) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListInvoicesParams) UnmarshalJSON(data []byte) error {
	type unmarshaler ListInvoicesParams
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListInvoicesParams(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListInvoicesParams) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListInvoicesResponse struct {
	Data []*InvoiceResponseData `json:"data,omitempty" url:"data,omitempty"`
	// Input parameters
	Params *ListInvoicesParams `json:"params,omitempty" url:"params,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListInvoicesResponse) GetData() []*InvoiceResponseData {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *ListInvoicesResponse) GetParams() *ListInvoicesParams {
	if l == nil {
		return nil
	}
	return l.Params
}

func (l *ListInvoicesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListInvoicesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListInvoicesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListInvoicesResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListInvoicesResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Input parameters
type ListMetersParams struct {
	DisplayName *string `json:"display_name,omitempty" url:"display_name,omitempty"`
	// Page limit (default 100)
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// Page offset (default 0)
	Offset *int `json:"offset,omitempty" url:"offset,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListMetersParams) GetDisplayName() *string {
	if l == nil {
		return nil
	}
	return l.DisplayName
}

func (l *ListMetersParams) GetLimit() *int {
	if l == nil {
		return nil
	}
	return l.Limit
}

func (l *ListMetersParams) GetOffset() *int {
	if l == nil {
		return nil
	}
	return l.Offset
}

func (l *ListMetersParams) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListMetersParams) UnmarshalJSON(data []byte) error {
	type unmarshaler ListMetersParams
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListMetersParams(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListMetersParams) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListMetersResponse struct {
	Data []*BillingMeterResponseData `json:"data,omitempty" url:"data,omitempty"`
	// Input parameters
	Params *ListMetersParams `json:"params,omitempty" url:"params,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListMetersResponse) GetData() []*BillingMeterResponseData {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *ListMetersResponse) GetParams() *ListMetersParams {
	if l == nil {
		return nil
	}
	return l.Params
}

func (l *ListMetersResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListMetersResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListMetersResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListMetersResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListMetersResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Input parameters
type ListPaymentMethodsParams struct {
	CompanyID          *string `json:"company_id,omitempty" url:"company_id,omitempty"`
	CustomerExternalID *string `json:"customer_external_id,omitempty" url:"customer_external_id,omitempty"`
	// Page limit (default 100)
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// Page offset (default 0)
	Offset *int `json:"offset,omitempty" url:"offset,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListPaymentMethodsParams) GetCompanyID() *string {
	if l == nil {
		return nil
	}
	return l.CompanyID
}

func (l *ListPaymentMethodsParams) GetCustomerExternalID() *string {
	if l == nil {
		return nil
	}
	return l.CustomerExternalID
}

func (l *ListPaymentMethodsParams) GetLimit() *int {
	if l == nil {
		return nil
	}
	return l.Limit
}

func (l *ListPaymentMethodsParams) GetOffset() *int {
	if l == nil {
		return nil
	}
	return l.Offset
}

func (l *ListPaymentMethodsParams) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListPaymentMethodsParams) UnmarshalJSON(data []byte) error {
	type unmarshaler ListPaymentMethodsParams
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListPaymentMethodsParams(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListPaymentMethodsParams) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListPaymentMethodsResponse struct {
	Data []*PaymentMethodResponseData `json:"data,omitempty" url:"data,omitempty"`
	// Input parameters
	Params *ListPaymentMethodsParams `json:"params,omitempty" url:"params,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListPaymentMethodsResponse) GetData() []*PaymentMethodResponseData {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *ListPaymentMethodsResponse) GetParams() *ListPaymentMethodsParams {
	if l == nil {
		return nil
	}
	return l.Params
}

func (l *ListPaymentMethodsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListPaymentMethodsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListPaymentMethodsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListPaymentMethodsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListPaymentMethodsResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Input parameters
type ListProductPricesParams struct {
	IDs []string `json:"ids,omitempty" url:"ids,omitempty"`
	// Filter products that are active
	IsActive *bool `json:"is_active,omitempty" url:"is_active,omitempty"`
	// Page limit (default 100)
	Limit *int    `json:"limit,omitempty" url:"limit,omitempty"`
	Name  *string `json:"name,omitempty" url:"name,omitempty"`
	// Page offset (default 0)
	Offset         *int                                           `json:"offset,omitempty" url:"offset,omitempty"`
	PriceUsageType *ListProductPricesResponseParamsPriceUsageType `json:"price_usage_type,omitempty" url:"price_usage_type,omitempty"`
	Q              *string                                        `json:"q,omitempty" url:"q,omitempty"`
	// Filter products that are one time charges
	WithOneTimeCharges *bool `json:"with_one_time_charges,omitempty" url:"with_one_time_charges,omitempty"`
	// Filter products that have prices
	WithPricesOnly *bool `json:"with_prices_only,omitempty" url:"with_prices_only,omitempty"`
	// Filter products that have zero price for free subscription type
	WithZeroPrice *bool `json:"with_zero_price,omitempty" url:"with_zero_price,omitempty"`
	// Filter products that are not linked to any plan
	WithoutLinkedToPlan *bool `json:"without_linked_to_plan,omitempty" url:"without_linked_to_plan,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListProductPricesParams) GetIDs() []string {
	if l == nil {
		return nil
	}
	return l.IDs
}

func (l *ListProductPricesParams) GetIsActive() *bool {
	if l == nil {
		return nil
	}
	return l.IsActive
}

func (l *ListProductPricesParams) GetLimit() *int {
	if l == nil {
		return nil
	}
	return l.Limit
}

func (l *ListProductPricesParams) GetName() *string {
	if l == nil {
		return nil
	}
	return l.Name
}

func (l *ListProductPricesParams) GetOffset() *int {
	if l == nil {
		return nil
	}
	return l.Offset
}

func (l *ListProductPricesParams) GetPriceUsageType() *ListProductPricesResponseParamsPriceUsageType {
	if l == nil {
		return nil
	}
	return l.PriceUsageType
}

func (l *ListProductPricesParams) GetQ() *string {
	if l == nil {
		return nil
	}
	return l.Q
}

func (l *ListProductPricesParams) GetWithOneTimeCharges() *bool {
	if l == nil {
		return nil
	}
	return l.WithOneTimeCharges
}

func (l *ListProductPricesParams) GetWithPricesOnly() *bool {
	if l == nil {
		return nil
	}
	return l.WithPricesOnly
}

func (l *ListProductPricesParams) GetWithZeroPrice() *bool {
	if l == nil {
		return nil
	}
	return l.WithZeroPrice
}

func (l *ListProductPricesParams) GetWithoutLinkedToPlan() *bool {
	if l == nil {
		return nil
	}
	return l.WithoutLinkedToPlan
}

func (l *ListProductPricesParams) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListProductPricesParams) UnmarshalJSON(data []byte) error {
	type unmarshaler ListProductPricesParams
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListProductPricesParams(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListProductPricesParams) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListProductPricesRequestPriceUsageType string

const (
	ListProductPricesRequestPriceUsageTypeLicensed ListProductPricesRequestPriceUsageType = "licensed"
	ListProductPricesRequestPriceUsageTypeMetered  ListProductPricesRequestPriceUsageType = "metered"
)

func NewListProductPricesRequestPriceUsageTypeFromString(s string) (ListProductPricesRequestPriceUsageType, error) {
	switch s {
	case "licensed":
		return ListProductPricesRequestPriceUsageTypeLicensed, nil
	case "metered":
		return ListProductPricesRequestPriceUsageTypeMetered, nil
	}
	var t ListProductPricesRequestPriceUsageType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l ListProductPricesRequestPriceUsageType) Ptr() *ListProductPricesRequestPriceUsageType {
	return &l
}

type ListProductPricesResponse struct {
	Data []*BillingPriceResponseData `json:"data,omitempty" url:"data,omitempty"`
	// Input parameters
	Params *ListProductPricesParams `json:"params,omitempty" url:"params,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListProductPricesResponse) GetData() []*BillingPriceResponseData {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *ListProductPricesResponse) GetParams() *ListProductPricesParams {
	if l == nil {
		return nil
	}
	return l.Params
}

func (l *ListProductPricesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListProductPricesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListProductPricesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListProductPricesResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListProductPricesResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListProductPricesResponseParamsPriceUsageType string

const (
	ListProductPricesResponseParamsPriceUsageTypeLicensed ListProductPricesResponseParamsPriceUsageType = "licensed"
	ListProductPricesResponseParamsPriceUsageTypeMetered  ListProductPricesResponseParamsPriceUsageType = "metered"
)

func NewListProductPricesResponseParamsPriceUsageTypeFromString(s string) (ListProductPricesResponseParamsPriceUsageType, error) {
	switch s {
	case "licensed":
		return ListProductPricesResponseParamsPriceUsageTypeLicensed, nil
	case "metered":
		return ListProductPricesResponseParamsPriceUsageTypeMetered, nil
	}
	var t ListProductPricesResponseParamsPriceUsageType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l ListProductPricesResponseParamsPriceUsageType) Ptr() *ListProductPricesResponseParamsPriceUsageType {
	return &l
}

// Input parameters
type SearchBillingPricesParams struct {
	// Filter for prices valid for initial plans (free prices only)
	ForInitialPlan *bool `json:"for_initial_plan,omitempty" url:"for_initial_plan,omitempty"`
	// Filter for prices valid for trial expiry plans (free prices only)
	ForTrialExpiryPlan *bool    `json:"for_trial_expiry_plan,omitempty" url:"for_trial_expiry_plan,omitempty"`
	IDs                []string `json:"ids,omitempty" url:"ids,omitempty"`
	Interval           *string  `json:"interval,omitempty" url:"interval,omitempty"`
	// Page limit (default 100)
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// Page offset (default 0)
	Offset    *int    `json:"offset,omitempty" url:"offset,omitempty"`
	Price     *int    `json:"price,omitempty" url:"price,omitempty"`
	ProductID *string `json:"product_id,omitempty" url:"product_id,omitempty"`
	Q         *string `json:"q,omitempty" url:"q,omitempty"`
	// Filter for prices that require a payment method (inverse of ForInitialPlan)
	RequiresPaymentMethod *bool                                       `json:"requires_payment_method,omitempty" url:"requires_payment_method,omitempty"`
	TiersMode             *SearchBillingPricesResponseParamsTiersMode `json:"tiers_mode,omitempty" url:"tiers_mode,omitempty"`
	UsageType             *SearchBillingPricesResponseParamsUsageType `json:"usage_type,omitempty" url:"usage_type,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SearchBillingPricesParams) GetForInitialPlan() *bool {
	if s == nil {
		return nil
	}
	return s.ForInitialPlan
}

func (s *SearchBillingPricesParams) GetForTrialExpiryPlan() *bool {
	if s == nil {
		return nil
	}
	return s.ForTrialExpiryPlan
}

func (s *SearchBillingPricesParams) GetIDs() []string {
	if s == nil {
		return nil
	}
	return s.IDs
}

func (s *SearchBillingPricesParams) GetInterval() *string {
	if s == nil {
		return nil
	}
	return s.Interval
}

func (s *SearchBillingPricesParams) GetLimit() *int {
	if s == nil {
		return nil
	}
	return s.Limit
}

func (s *SearchBillingPricesParams) GetOffset() *int {
	if s == nil {
		return nil
	}
	return s.Offset
}

func (s *SearchBillingPricesParams) GetPrice() *int {
	if s == nil {
		return nil
	}
	return s.Price
}

func (s *SearchBillingPricesParams) GetProductID() *string {
	if s == nil {
		return nil
	}
	return s.ProductID
}

func (s *SearchBillingPricesParams) GetQ() *string {
	if s == nil {
		return nil
	}
	return s.Q
}

func (s *SearchBillingPricesParams) GetRequiresPaymentMethod() *bool {
	if s == nil {
		return nil
	}
	return s.RequiresPaymentMethod
}

func (s *SearchBillingPricesParams) GetTiersMode() *SearchBillingPricesResponseParamsTiersMode {
	if s == nil {
		return nil
	}
	return s.TiersMode
}

func (s *SearchBillingPricesParams) GetUsageType() *SearchBillingPricesResponseParamsUsageType {
	if s == nil {
		return nil
	}
	return s.UsageType
}

func (s *SearchBillingPricesParams) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchBillingPricesParams) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchBillingPricesParams
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchBillingPricesParams(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchBillingPricesParams) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SearchBillingPricesRequestTiersMode string

const (
	SearchBillingPricesRequestTiersModeVolume    SearchBillingPricesRequestTiersMode = "volume"
	SearchBillingPricesRequestTiersModeGraduated SearchBillingPricesRequestTiersMode = "graduated"
)

func NewSearchBillingPricesRequestTiersModeFromString(s string) (SearchBillingPricesRequestTiersMode, error) {
	switch s {
	case "volume":
		return SearchBillingPricesRequestTiersModeVolume, nil
	case "graduated":
		return SearchBillingPricesRequestTiersModeGraduated, nil
	}
	var t SearchBillingPricesRequestTiersMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SearchBillingPricesRequestTiersMode) Ptr() *SearchBillingPricesRequestTiersMode {
	return &s
}

type SearchBillingPricesRequestUsageType string

const (
	SearchBillingPricesRequestUsageTypeLicensed SearchBillingPricesRequestUsageType = "licensed"
	SearchBillingPricesRequestUsageTypeMetered  SearchBillingPricesRequestUsageType = "metered"
)

func NewSearchBillingPricesRequestUsageTypeFromString(s string) (SearchBillingPricesRequestUsageType, error) {
	switch s {
	case "licensed":
		return SearchBillingPricesRequestUsageTypeLicensed, nil
	case "metered":
		return SearchBillingPricesRequestUsageTypeMetered, nil
	}
	var t SearchBillingPricesRequestUsageType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SearchBillingPricesRequestUsageType) Ptr() *SearchBillingPricesRequestUsageType {
	return &s
}

type SearchBillingPricesResponse struct {
	Data []*BillingPriceView `json:"data,omitempty" url:"data,omitempty"`
	// Input parameters
	Params *SearchBillingPricesParams `json:"params,omitempty" url:"params,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SearchBillingPricesResponse) GetData() []*BillingPriceView {
	if s == nil {
		return nil
	}
	return s.Data
}

func (s *SearchBillingPricesResponse) GetParams() *SearchBillingPricesParams {
	if s == nil {
		return nil
	}
	return s.Params
}

func (s *SearchBillingPricesResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchBillingPricesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchBillingPricesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchBillingPricesResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchBillingPricesResponse) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SearchBillingPricesResponseParamsTiersMode string

const (
	SearchBillingPricesResponseParamsTiersModeVolume    SearchBillingPricesResponseParamsTiersMode = "volume"
	SearchBillingPricesResponseParamsTiersModeGraduated SearchBillingPricesResponseParamsTiersMode = "graduated"
)

func NewSearchBillingPricesResponseParamsTiersModeFromString(s string) (SearchBillingPricesResponseParamsTiersMode, error) {
	switch s {
	case "volume":
		return SearchBillingPricesResponseParamsTiersModeVolume, nil
	case "graduated":
		return SearchBillingPricesResponseParamsTiersModeGraduated, nil
	}
	var t SearchBillingPricesResponseParamsTiersMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SearchBillingPricesResponseParamsTiersMode) Ptr() *SearchBillingPricesResponseParamsTiersMode {
	return &s
}

type SearchBillingPricesResponseParamsUsageType string

const (
	SearchBillingPricesResponseParamsUsageTypeLicensed SearchBillingPricesResponseParamsUsageType = "licensed"
	SearchBillingPricesResponseParamsUsageTypeMetered  SearchBillingPricesResponseParamsUsageType = "metered"
)

func NewSearchBillingPricesResponseParamsUsageTypeFromString(s string) (SearchBillingPricesResponseParamsUsageType, error) {
	switch s {
	case "licensed":
		return SearchBillingPricesResponseParamsUsageTypeLicensed, nil
	case "metered":
		return SearchBillingPricesResponseParamsUsageTypeMetered, nil
	}
	var t SearchBillingPricesResponseParamsUsageType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SearchBillingPricesResponseParamsUsageType) Ptr() *SearchBillingPricesResponseParamsUsageType {
	return &s
}

type UpsertBillingCouponResponse struct {
	Data *BillingCouponResponseData `json:"data,omitempty" url:"data,omitempty"`
	// Input parameters
	Params map[string]interface{} `json:"params,omitempty" url:"params,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpsertBillingCouponResponse) GetData() *BillingCouponResponseData {
	if u == nil {
		return nil
	}
	return u.Data
}

func (u *UpsertBillingCouponResponse) GetParams() map[string]interface{} {
	if u == nil {
		return nil
	}
	return u.Params
}

func (u *UpsertBillingCouponResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpsertBillingCouponResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpsertBillingCouponResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpsertBillingCouponResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpsertBillingCouponResponse) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpsertBillingCustomerResponse struct {
	Data *BillingCustomerResponseData `json:"data,omitempty" url:"data,omitempty"`
	// Input parameters
	Params map[string]interface{} `json:"params,omitempty" url:"params,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpsertBillingCustomerResponse) GetData() *BillingCustomerResponseData {
	if u == nil {
		return nil
	}
	return u.Data
}

func (u *UpsertBillingCustomerResponse) GetParams() map[string]interface{} {
	if u == nil {
		return nil
	}
	return u.Params
}

func (u *UpsertBillingCustomerResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpsertBillingCustomerResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpsertBillingCustomerResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpsertBillingCustomerResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpsertBillingCustomerResponse) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpsertBillingMeterResponse struct {
	Data *BillingMeterResponseData `json:"data,omitempty" url:"data,omitempty"`
	// Input parameters
	Params map[string]interface{} `json:"params,omitempty" url:"params,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpsertBillingMeterResponse) GetData() *BillingMeterResponseData {
	if u == nil {
		return nil
	}
	return u.Data
}

func (u *UpsertBillingMeterResponse) GetParams() map[string]interface{} {
	if u == nil {
		return nil
	}
	return u.Params
}

func (u *UpsertBillingMeterResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpsertBillingMeterResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpsertBillingMeterResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpsertBillingMeterResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpsertBillingMeterResponse) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpsertBillingPriceResponse struct {
	Data *BillingPriceResponseData `json:"data,omitempty" url:"data,omitempty"`
	// Input parameters
	Params map[string]interface{} `json:"params,omitempty" url:"params,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpsertBillingPriceResponse) GetData() *BillingPriceResponseData {
	if u == nil {
		return nil
	}
	return u.Data
}

func (u *UpsertBillingPriceResponse) GetParams() map[string]interface{} {
	if u == nil {
		return nil
	}
	return u.Params
}

func (u *UpsertBillingPriceResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpsertBillingPriceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpsertBillingPriceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpsertBillingPriceResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpsertBillingPriceResponse) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpsertBillingProductResponse struct {
	Data *BillingProductResponseData `json:"data,omitempty" url:"data,omitempty"`
	// Input parameters
	Params map[string]interface{} `json:"params,omitempty" url:"params,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpsertBillingProductResponse) GetData() *BillingProductResponseData {
	if u == nil {
		return nil
	}
	return u.Data
}

func (u *UpsertBillingProductResponse) GetParams() map[string]interface{} {
	if u == nil {
		return nil
	}
	return u.Params
}

func (u *UpsertBillingProductResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpsertBillingProductResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpsertBillingProductResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpsertBillingProductResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpsertBillingProductResponse) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpsertBillingSubscriptionResponse struct {
	Data *BillingSubscriptionResponseData `json:"data,omitempty" url:"data,omitempty"`
	// Input parameters
	Params map[string]interface{} `json:"params,omitempty" url:"params,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpsertBillingSubscriptionResponse) GetData() *BillingSubscriptionResponseData {
	if u == nil {
		return nil
	}
	return u.Data
}

func (u *UpsertBillingSubscriptionResponse) GetParams() map[string]interface{} {
	if u == nil {
		return nil
	}
	return u.Params
}

func (u *UpsertBillingSubscriptionResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpsertBillingSubscriptionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpsertBillingSubscriptionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpsertBillingSubscriptionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpsertBillingSubscriptionResponse) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpsertInvoiceResponse struct {
	Data *InvoiceResponseData `json:"data,omitempty" url:"data,omitempty"`
	// Input parameters
	Params map[string]interface{} `json:"params,omitempty" url:"params,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpsertInvoiceResponse) GetData() *InvoiceResponseData {
	if u == nil {
		return nil
	}
	return u.Data
}

func (u *UpsertInvoiceResponse) GetParams() map[string]interface{} {
	if u == nil {
		return nil
	}
	return u.Params
}

func (u *UpsertInvoiceResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpsertInvoiceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpsertInvoiceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpsertInvoiceResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpsertInvoiceResponse) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpsertPaymentMethodResponse struct {
	Data *PaymentMethodResponseData `json:"data,omitempty" url:"data,omitempty"`
	// Input parameters
	Params map[string]interface{} `json:"params,omitempty" url:"params,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpsertPaymentMethodResponse) GetData() *PaymentMethodResponseData {
	if u == nil {
		return nil
	}
	return u.Data
}

func (u *UpsertPaymentMethodResponse) GetParams() map[string]interface{} {
	if u == nil {
		return nil
	}
	return u.Params
}

func (u *UpsertPaymentMethodResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpsertPaymentMethodResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpsertPaymentMethodResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpsertPaymentMethodResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpsertPaymentMethodResponse) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type CreateCouponRequestBody struct {
	AmountOff        int     `json:"amount_off" url:"-"`
	Currency         *string `json:"currency,omitempty" url:"-"`
	Duration         string  `json:"duration" url:"-"`
	DurationInMonths int     `json:"duration_in_months" url:"-"`
	ExternalID       string  `json:"external_id" url:"-"`
	MaxRedemptions   int     `json:"max_redemptions" url:"-"`
	Name             string  `json:"name" url:"-"`
	PercentOff       float64 `json:"percent_off" url:"-"`
	TimesRedeemed    int     `json:"times_redeemed" url:"-"`
}

type CreateBillingCustomerRequestBody struct {
	CompanyID              *string           `json:"company_id,omitempty" url:"-"`
	DefaultPaymentMethodID *string           `json:"default_payment_method_id,omitempty" url:"-"`
	Email                  string            `json:"email" url:"-"`
	ExternalID             string            `json:"external_id" url:"-"`
	FailedToImport         bool              `json:"failed_to_import" url:"-"`
	Meta                   map[string]string `json:"meta,omitempty" url:"-"`
	Name                   string            `json:"name" url:"-"`
}

type CreateMeterRequestBody struct {
	DisplayName     string `json:"display_name" url:"-"`
	EventName       string `json:"event_name" url:"-"`
	EventPayloadKey string `json:"event_payload_key" url:"-"`
	ExternalID      string `json:"external_id" url:"-"`
}

type CreateBillingPriceRequestBody struct {
	BillingScheme     CreateBillingPriceRequestBodyBillingScheme `json:"billing_scheme" url:"-"`
	Currency          string                                     `json:"currency" url:"-"`
	ExternalAccountID string                                     `json:"external_account_id" url:"-"`
	Interval          string                                     `json:"interval" url:"-"`
	IsActive          bool                                       `json:"is_active" url:"-"`
	MeterID           *string                                    `json:"meter_id,omitempty" url:"-"`
	PackageSize       *int                                       `json:"package_size,omitempty" url:"-"`
	Price             int                                        `json:"price" url:"-"`
	PriceDecimal      *string                                    `json:"price_decimal,omitempty" url:"-"`
	PriceExternalID   string                                     `json:"price_external_id" url:"-"`
	PriceTiers        []*CreateBillingPriceTierRequestBody       `json:"price_tiers,omitempty" url:"-"`
	ProductExternalID string                                     `json:"product_external_id" url:"-"`
	TiersMode         *CreateBillingPriceRequestBodyTiersMode    `json:"tiers_mode,omitempty" url:"-"`
	UsageType         CreateBillingPriceRequestBodyUsageType     `json:"usage_type" url:"-"`
}

type CreateBillingProductRequestBody struct {
	ExternalID string  `json:"external_id" url:"-"`
	IsActive   *bool   `json:"is_active,omitempty" url:"-"`
	Name       string  `json:"name" url:"-"`
	Price      float64 `json:"price" url:"-"`
}

type CreateBillingSubscriptionRequestBody struct {
	CancelAt               *int                                                 `json:"cancel_at,omitempty" url:"-"`
	CancelAtPeriodEnd      bool                                                 `json:"cancel_at_period_end" url:"-"`
	Currency               string                                               `json:"currency" url:"-"`
	CustomerExternalID     string                                               `json:"customer_external_id" url:"-"`
	DefaultPaymentMethodID *string                                              `json:"default_payment_method_id,omitempty" url:"-"`
	Discounts              []*BillingSubscriptionDiscount                       `json:"discounts,omitempty" url:"-"`
	ExpiredAt              time.Time                                            `json:"expired_at" url:"-"`
	Interval               *string                                              `json:"interval,omitempty" url:"-"`
	Metadata               map[string]interface{}                               `json:"metadata,omitempty" url:"-"`
	PeriodEnd              *int                                                 `json:"period_end,omitempty" url:"-"`
	PeriodStart            *int                                                 `json:"period_start,omitempty" url:"-"`
	ProductExternalIDs     []*BillingProductPricing                             `json:"product_external_ids,omitempty" url:"-"`
	Status                 *string                                              `json:"status,omitempty" url:"-"`
	SubscriptionExternalID string                                               `json:"subscription_external_id" url:"-"`
	TotalPrice             int                                                  `json:"total_price" url:"-"`
	TrialEnd               *int                                                 `json:"trial_end,omitempty" url:"-"`
	TrialEndSetting        *CreateBillingSubscriptionRequestBodyTrialEndSetting `json:"trial_end_setting,omitempty" url:"-"`
}

func (c *CreateBillingSubscriptionRequestBody) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateBillingSubscriptionRequestBody
	var body unmarshaler
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	*c = CreateBillingSubscriptionRequestBody(body)
	return nil
}

func (c *CreateBillingSubscriptionRequestBody) MarshalJSON() ([]byte, error) {
	type embed CreateBillingSubscriptionRequestBody
	var marshaler = struct {
		embed
		ExpiredAt *internal.DateTime `json:"expired_at"`
	}{
		embed:     embed(*c),
		ExpiredAt: internal.NewDateTime(c.ExpiredAt),
	}
	return json.Marshal(marshaler)
}

type CreateInvoiceRequestBody struct {
	AmountDue               int        `json:"amount_due" url:"-"`
	AmountPaid              int        `json:"amount_paid" url:"-"`
	AmountRemaining         int        `json:"amount_remaining" url:"-"`
	CollectionMethod        string     `json:"collection_method" url:"-"`
	Currency                string     `json:"currency" url:"-"`
	CustomerExternalID      string     `json:"customer_external_id" url:"-"`
	DueDate                 *time.Time `json:"due_date,omitempty" url:"-"`
	ExternalID              *string    `json:"external_id,omitempty" url:"-"`
	PaymentMethodExternalID *string    `json:"payment_method_external_id,omitempty" url:"-"`
	SubscriptionExternalID  *string    `json:"subscription_external_id,omitempty" url:"-"`
	Subtotal                int        `json:"subtotal" url:"-"`
	URL                     *string    `json:"url,omitempty" url:"-"`
}

func (c *CreateInvoiceRequestBody) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateInvoiceRequestBody
	var body unmarshaler
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	*c = CreateInvoiceRequestBody(body)
	return nil
}

func (c *CreateInvoiceRequestBody) MarshalJSON() ([]byte, error) {
	type embed CreateInvoiceRequestBody
	var marshaler = struct {
		embed
		DueDate *internal.DateTime `json:"due_date,omitempty"`
	}{
		embed:   embed(*c),
		DueDate: internal.NewOptionalDateTime(c.DueDate),
	}
	return json.Marshal(marshaler)
}

type CreatePaymentMethodRequestBody struct {
	AccountLast4       *string `json:"account_last4,omitempty" url:"-"`
	AccountName        *string `json:"account_name,omitempty" url:"-"`
	BankName           *string `json:"bank_name,omitempty" url:"-"`
	BillingEmail       *string `json:"billing_email,omitempty" url:"-"`
	BillingName        *string `json:"billing_name,omitempty" url:"-"`
	CardBrand          *string `json:"card_brand,omitempty" url:"-"`
	CardExpMonth       *int    `json:"card_exp_month,omitempty" url:"-"`
	CardExpYear        *int    `json:"card_exp_year,omitempty" url:"-"`
	CardLast4          *string `json:"card_last4,omitempty" url:"-"`
	CustomerExternalID string  `json:"customer_external_id" url:"-"`
	ExternalID         string  `json:"external_id" url:"-"`
	PaymentMethodType  string  `json:"payment_method_type" url:"-"`
}
