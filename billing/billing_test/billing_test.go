// Code generated by Fern. DO NOT EDIT.

package billing_test

import (
	context "context"
	fmt "fmt"
	schematicgo "github.com/schematichq/schematic-go"
	client "github.com/schematichq/schematic-go/client"
	option "github.com/schematichq/schematic-go/option"
	require "github.com/stretchr/testify/require"
	gowiremock "github.com/wiremock/go-wiremock"
	wiremocktestcontainersgo "github.com/wiremock/wiremock-testcontainers-go"
	http "net/http"
	os "os"
	testing "testing"
)

// TestMain sets up shared test fixtures for all tests in this package// Global test fixtures
var (
	WireMockContainer *wiremocktestcontainersgo.WireMockContainer
	WireMockBaseURL   string
	WireMockClient    *gowiremock.Client
)

// TestMain sets up shared test fixtures for all tests in this package
func TestMain(m *testing.M) {
	// Setup shared WireMock container
	ctx := context.Background()
	container, err := wiremocktestcontainersgo.RunContainerAndStopOnCleanup(
		ctx,
		&testing.T{},
		wiremocktestcontainersgo.WithImage("docker.io/wiremock/wiremock:3.9.1"),
	)
	if err != nil {
		fmt.Printf("Failed to start WireMock container: %v\n", err)
		os.Exit(1)
	}

	// Store global references
	WireMockContainer = container

	// Try to get the base URL using the standard method first
	baseURL, err := container.Endpoint(ctx, "")
	if err == nil {
		// Standard method worked (running outside DinD)
		// This uses the mapped port (e.g., localhost:59553)
		WireMockBaseURL = "http://" + baseURL
		WireMockClient = container.Client
	} else {
		// Standard method failed, use internal IP fallback (DinD environment)
		fmt.Printf("Standard endpoint resolution failed, using internal IP fallback: %v\n", err)

		inspect, err := container.Inspect(ctx)
		if err != nil {
			fmt.Printf("Failed to inspect WireMock container: %v\n", err)
			os.Exit(1)
		}

		// Find the IP address from the container's networks
		var containerIP string
		for _, network := range inspect.NetworkSettings.Networks {
			if network.IPAddress != "" {
				containerIP = network.IPAddress
				break
			}
		}

		if containerIP == "" {
			fmt.Printf("Failed to get WireMock container IP address\n")
			os.Exit(1)
		}

		// In DinD, use the internal port directly (8080 for WireMock HTTP)
		// Don't use the mapped port since it doesn't exist in this environment
		WireMockBaseURL = fmt.Sprintf("http://%s:8080", containerIP)

		// The container.Client was created with a bad URL, so we need a new one
		WireMockClient = gowiremock.NewClient(WireMockBaseURL)
	}

	fmt.Printf("WireMock available at: %s\n", WireMockBaseURL)

	// Run all tests
	code := m.Run()

	// Cleanup
	if WireMockContainer != nil {
		WireMockContainer.Terminate(ctx)
	}

	// Exit with the same code as the tests
	os.Exit(code)
}

func TestBillingListCouponsWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Get(gowiremock.URLPathTemplate("/billing/coupons")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": []interface{}{map[string]interface{}{"account_id": "account_id", "amount_off": 1, "currency": "currency", "duration": "duration", "duration_in_months": 1, "environment_id": "environment_id", "external_id": "external_id", "id": "id", "is_active": true, "max_redemptions": 1, "metadata": map[string]interface{}{"key": "value"}, "name": "name", "percent_off": 1.1, "times_redeemed": 1, "valid_from": "2024-01-15T09:30:00Z", "valid_until": "2024-01-15T09:30:00Z"}}, "params": map[string]interface{}{"is_active": true, "limit": 1, "offset": 1, "q": "q"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.ListCouponsRequest{
		IsActive: schematichq.Bool(
			true,
		),
		Q: schematichq.String(
			"q",
		),
		Limit: schematichq.Int(
			1,
		),
		Offset: schematichq.Int(
			1,
		),
	}
	_, invocationErr := client.Billing.ListCoupons(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestBillingUpsertBillingCouponWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Post(gowiremock.URLPathTemplate("/billing/coupons")).WithBodyPattern(gowiremock.MatchesJsonSchema(`{
                    "$schema": "https://json-schema.org/draft/2020-12/schema",
                    "type": "object",
                    "required": ["amount_off", "duration", "duration_in_months", "external_id", "max_redemptions", "name", "percent_off", "times_redeemed"],
                    "properties": {
                        "amount_off": {"type": "integer"}, "duration": {"type": "string"}, "duration_in_months": {"type": "integer"}, "external_id": {"type": "string"}, "max_redemptions": {"type": "integer"}, "name": {"type": "string"}, "percent_off": {"type": "number"}, "times_redeemed": {"type": "integer"}
                    },
                    "additionalProperties": true
                }`, "V202012")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": map[string]interface{}{"account_id": "account_id", "amount_off": 1, "currency": "currency", "duration": "duration", "duration_in_months": 1, "environment_id": "environment_id", "external_id": "external_id", "id": "id", "is_active": true, "max_redemptions": 1, "metadata": map[string]interface{}{"key": "value"}, "name": "name", "percent_off": 1.1, "times_redeemed": 1, "valid_from": "2024-01-15T09:30:00Z", "valid_until": "2024-01-15T09:30:00Z"}, "params": map[string]interface{}{"key": "value"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.CreateCouponRequestBody{
		AmountOff:        1,
		Duration:         "duration",
		DurationInMonths: 1,
		ExternalID:       "external_id",
		MaxRedemptions:   1,
		Name:             "name",
		PercentOff:       1.1,
		TimesRedeemed:    1,
	}
	_, invocationErr := client.Billing.UpsertBillingCoupon(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestBillingUpsertBillingCustomerWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Post(gowiremock.URLPathTemplate("/billing/customer/upsert")).WithBodyPattern(gowiremock.MatchesJsonSchema(`{
                    "$schema": "https://json-schema.org/draft/2020-12/schema",
                    "type": "object",
                    "required": ["email", "external_id", "failed_to_import", "meta", "name"],
                    "properties": {
                        "email": {"type": "string"}, "external_id": {"type": "string"}, "failed_to_import": {"type": "boolean"}, "meta": {"type": "object", "additionalProperties": {"type": "string"}}, "name": {"type": "string"}
                    },
                    "additionalProperties": true
                }`, "V202012")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": map[string]interface{}{"company_id": "company_id", "deleted_at": "2024-01-15T09:30:00Z", "email": "email", "external_id": "external_id", "failed_to_import": true, "id": "id", "name": "name", "updated_at": "2024-01-15T09:30:00Z"}, "params": map[string]interface{}{"key": "value"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.CreateBillingCustomerRequestBody{
		Email:          "email",
		ExternalID:     "external_id",
		FailedToImport: true,
		Meta: map[string]string{
			"key": "value",
		},
		Name: "name",
	}
	_, invocationErr := client.Billing.UpsertBillingCustomer(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestBillingListCustomersWithSubscriptionsWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Get(gowiremock.URLPathTemplate("/billing/customers")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": []interface{}{map[string]interface{}{"company_id": "company_id", "deleted_at": "2024-01-15T09:30:00Z", "email": "email", "external_id": "external_id", "failed_to_import": true, "id": "id", "name": "name", "subscriptions": []interface{}{map[string]interface{}{"currency": "currency", "interval": "interval", "metered_usage": true, "per_unit_price": 1, "total_price": 1}}, "updated_at": "2024-01-15T09:30:00Z"}}, "params": map[string]interface{}{"company_ids": []interface{}{"company_ids"}, "failed_to_import": true, "limit": 1, "name": "name", "offset": 1, "q": "q"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.ListCustomersWithSubscriptionsRequest{
		Name: schematichq.String(
			"name",
		),
		FailedToImport: schematichq.Bool(
			true,
		),
		Q: schematichq.String(
			"q",
		),
		Limit: schematichq.Int(
			1,
		),
		Offset: schematichq.Int(
			1,
		),
	}
	_, invocationErr := client.Billing.ListCustomersWithSubscriptions(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestBillingCountCustomersWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Get(gowiremock.URLPathTemplate("/billing/customers/count")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": map[string]interface{}{"count": 1}, "params": map[string]interface{}{"company_ids": []interface{}{"company_ids"}, "failed_to_import": true, "limit": 1, "name": "name", "offset": 1, "q": "q"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.CountCustomersRequest{
		Name: schematichq.String(
			"name",
		),
		FailedToImport: schematichq.Bool(
			true,
		),
		Q: schematichq.String(
			"q",
		),
		Limit: schematichq.Int(
			1,
		),
		Offset: schematichq.Int(
			1,
		),
	}
	_, invocationErr := client.Billing.CountCustomers(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestBillingListInvoicesWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Get(gowiremock.URLPathTemplate("/billing/invoices")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": []interface{}{map[string]interface{}{"amount_due": 1, "amount_paid": 1, "amount_remaining": 1, "collection_method": "collection_method", "company_id": "company_id", "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "customer_external_id": "customer_external_id", "due_date": "2024-01-15T09:30:00Z", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "payment_method_external_id": "payment_method_external_id", "subscription_external_id": "subscription_external_id", "subtotal": 1, "updated_at": "2024-01-15T09:30:00Z", "url": "url"}}, "params": map[string]interface{}{"company_id": "company_id", "customer_external_id": "customer_external_id", "limit": 1, "offset": 1, "subscription_external_id": "subscription_external_id"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.ListInvoicesRequest{
		CompanyID: schematichq.String(
			"company_id",
		),
		CustomerExternalID:     "customer_external_id",
		SubscriptionExternalID: "subscription_external_id",
		Limit: schematichq.Int(
			1,
		),
		Offset: schematichq.Int(
			1,
		),
	}
	_, invocationErr := client.Billing.ListInvoices(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestBillingUpsertInvoiceWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Post(gowiremock.URLPathTemplate("/billing/invoices")).WithBodyPattern(gowiremock.MatchesJsonSchema(`{
                    "$schema": "https://json-schema.org/draft/2020-12/schema",
                    "type": "object",
                    "required": ["amount_due", "amount_paid", "amount_remaining", "collection_method", "currency", "customer_external_id", "subtotal"],
                    "properties": {
                        "amount_due": {"type": "integer"}, "amount_paid": {"type": "integer"}, "amount_remaining": {"type": "integer"}, "collection_method": {"type": "string"}, "currency": {"type": "string"}, "customer_external_id": {"type": "string"}, "subtotal": {"type": "integer"}
                    },
                    "additionalProperties": true
                }`, "V202012")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": map[string]interface{}{"amount_due": 1, "amount_paid": 1, "amount_remaining": 1, "collection_method": "collection_method", "company_id": "company_id", "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "customer_external_id": "customer_external_id", "due_date": "2024-01-15T09:30:00Z", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "payment_method_external_id": "payment_method_external_id", "subscription_external_id": "subscription_external_id", "subtotal": 1, "updated_at": "2024-01-15T09:30:00Z", "url": "url"}, "params": map[string]interface{}{"key": "value"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.CreateInvoiceRequestBody{
		AmountDue:          1,
		AmountPaid:         1,
		AmountRemaining:    1,
		CollectionMethod:   "collection_method",
		Currency:           "currency",
		CustomerExternalID: "customer_external_id",
		Subtotal:           1,
	}
	_, invocationErr := client.Billing.UpsertInvoice(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestBillingListMetersWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Get(gowiremock.URLPathTemplate("/billing/meter")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": []interface{}{map[string]interface{}{"dispaly_name": "dispaly_name", "event_name": "event_name", "event_payload_key": "event_payload_key", "external_price_id": "external_price_id", "id": "id"}}, "params": map[string]interface{}{"display_name": "display_name", "limit": 1, "offset": 1}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.ListMetersRequest{
		DisplayName: schematichq.String(
			"display_name",
		),
		Limit: schematichq.Int(
			1,
		),
		Offset: schematichq.Int(
			1,
		),
	}
	_, invocationErr := client.Billing.ListMeters(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestBillingUpsertBillingMeterWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Post(gowiremock.URLPathTemplate("/billing/meter/upsert")).WithBodyPattern(gowiremock.MatchesJsonSchema(`{
                    "$schema": "https://json-schema.org/draft/2020-12/schema",
                    "type": "object",
                    "required": ["display_name", "event_name", "event_payload_key", "external_id"],
                    "properties": {
                        "display_name": {"type": "string"}, "event_name": {"type": "string"}, "event_payload_key": {"type": "string"}, "external_id": {"type": "string"}
                    },
                    "additionalProperties": true
                }`, "V202012")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": map[string]interface{}{"dispaly_name": "dispaly_name", "event_name": "event_name", "event_payload_key": "event_payload_key", "external_price_id": "external_price_id", "id": "id"}, "params": map[string]interface{}{"key": "value"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.CreateMeterRequestBody{
		DisplayName:     "display_name",
		EventName:       "event_name",
		EventPayloadKey: "event_payload_key",
		ExternalID:      "external_id",
	}
	_, invocationErr := client.Billing.UpsertBillingMeter(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestBillingListPaymentMethodsWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Get(gowiremock.URLPathTemplate("/billing/payment-methods")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": []interface{}{map[string]interface{}{"account_last4": "account_last4", "account_name": "account_name", "bank_name": "bank_name", "billing_email": "billing_email", "billing_name": "billing_name", "card_brand": "card_brand", "card_exp_month": 1, "card_exp_year": 1, "card_last4": "card_last4", "company_id": "company_id", "created_at": "2024-01-15T09:30:00Z", "customer_external_id": "customer_external_id", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "payment_method_type": "payment_method_type", "updated_at": "2024-01-15T09:30:00Z"}}, "params": map[string]interface{}{"company_id": "company_id", "customer_external_id": "customer_external_id", "limit": 1, "offset": 1}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.ListPaymentMethodsRequest{
		CompanyID: schematichq.String(
			"company_id",
		),
		CustomerExternalID: "customer_external_id",
		Limit: schematichq.Int(
			1,
		),
		Offset: schematichq.Int(
			1,
		),
	}
	_, invocationErr := client.Billing.ListPaymentMethods(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestBillingUpsertPaymentMethodWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Post(gowiremock.URLPathTemplate("/billing/payment-methods")).WithBodyPattern(gowiremock.MatchesJsonSchema(`{
                    "$schema": "https://json-schema.org/draft/2020-12/schema",
                    "type": "object",
                    "required": ["customer_external_id", "external_id", "payment_method_type"],
                    "properties": {
                        "customer_external_id": {"type": "string"}, "external_id": {"type": "string"}, "payment_method_type": {"type": "string"}
                    },
                    "additionalProperties": true
                }`, "V202012")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": map[string]interface{}{"account_last4": "account_last4", "account_name": "account_name", "bank_name": "bank_name", "billing_email": "billing_email", "billing_name": "billing_name", "card_brand": "card_brand", "card_exp_month": 1, "card_exp_year": 1, "card_last4": "card_last4", "company_id": "company_id", "created_at": "2024-01-15T09:30:00Z", "customer_external_id": "customer_external_id", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "payment_method_type": "payment_method_type", "updated_at": "2024-01-15T09:30:00Z"}, "params": map[string]interface{}{"key": "value"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.CreatePaymentMethodRequestBody{
		CustomerExternalID: "customer_external_id",
		ExternalID:         "external_id",
		PaymentMethodType:  "payment_method_type",
	}
	_, invocationErr := client.Billing.UpsertPaymentMethod(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestBillingSearchBillingPricesWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Get(gowiremock.URLPathTemplate("/billing/price")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": []interface{}{map[string]interface{}{"billing_scheme": "billing_scheme", "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "id": "id", "interval": "interval", "is_active": true, "meter_event_name": "meter_event_name", "meter_event_payload_key": "meter_event_payload_key", "meter_id": "meter_id", "package_size": 1, "price": 1, "price_decimal": "price_decimal", "price_external_id": "price_external_id", "price_id": "price_id", "price_tier": []interface{}{map[string]interface{}{}}, "product_external_id": "product_external_id", "product_id": "product_id", "product_name": "product_name", "tiers_mode": "tiers_mode", "updated_at": "2024-01-15T09:30:00Z", "usage_type": "usage_type"}}, "params": map[string]interface{}{"for_initial_plan": true, "for_trial_expiry_plan": true, "ids": []interface{}{"ids"}, "interval": "interval", "limit": 1, "offset": 1, "price": 1, "product_id": "product_id", "q": "q", "requires_payment_method": true, "tiers_mode": "volume", "usage_type": "licensed"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.SearchBillingPricesRequest{
		ForInitialPlan: schematichq.Bool(
			true,
		),
		ForTrialExpiryPlan: schematichq.Bool(
			true,
		),
		ProductID: schematichq.String(
			"product_id",
		),
		Interval: schematichq.String(
			"interval",
		),
		Price: schematichq.Int(
			1,
		),
		Q: schematichq.String(
			"q",
		),
		RequiresPaymentMethod: schematichq.Bool(
			true,
		),
		TiersMode: schematichq.SearchBillingPricesRequestTiersModeVolume.Ptr(),
		UsageType: schematichq.SearchBillingPricesRequestUsageTypeLicensed.Ptr(),
		Limit: schematichq.Int(
			1,
		),
		Offset: schematichq.Int(
			1,
		),
	}
	_, invocationErr := client.Billing.SearchBillingPrices(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestBillingUpsertBillingPriceWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Post(gowiremock.URLPathTemplate("/billing/price/upsert")).WithBodyPattern(gowiremock.MatchesJsonSchema(`{
                    "$schema": "https://json-schema.org/draft/2020-12/schema",
                    "type": "object",
                    "required": ["billing_scheme", "currency", "external_account_id", "interval", "is_active", "price", "price_external_id", "price_tiers", "product_external_id", "usage_type"],
                    "properties": {
                        "billing_scheme": {"type": "string"}, "currency": {"type": "string"}, "external_account_id": {"type": "string"}, "interval": {"type": "string"}, "is_active": {"type": "boolean"}, "price": {"type": "integer"}, "price_external_id": {"type": "string"}, "price_tiers": {"type": "array", "items": {"type": "object"}}, "product_external_id": {"type": "string"}, "usage_type": {"type": "string"}
                    },
                    "additionalProperties": true
                }`, "V202012")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": map[string]interface{}{"currency": "currency", "external_price_id": "external_price_id", "id": "id", "interval": "interval", "price": 1, "price_decimal": "price_decimal", "scheme": "scheme"}, "params": map[string]interface{}{"key": "value"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.CreateBillingPriceRequestBody{
		BillingScheme:     schematichq.CreateBillingPriceRequestBodyBillingSchemePerUnit,
		Currency:          "currency",
		ExternalAccountID: "external_account_id",
		Interval:          "interval",
		IsActive:          true,
		Price:             1,
		PriceExternalID:   "price_external_id",
		PriceTiers: []*schematichq.CreateBillingPriceTierRequestBody{
			&schematichq.CreateBillingPriceTierRequestBody{
				PriceExternalID: "price_external_id",
			},
		},
		ProductExternalID: "product_external_id",
		UsageType:         schematichq.CreateBillingPriceRequestBodyUsageTypeLicensed,
	}
	_, invocationErr := client.Billing.UpsertBillingPrice(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestBillingDeleteBillingProductWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Delete(gowiremock.URLPathTemplate("/billing/product/{billing_id}")).WithPathParam(
		"billing_id",
		gowiremock.Matching("billing_id"),
	).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": map[string]interface{}{"deleted": true}, "params": map[string]interface{}{"key": "value"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	_, invocationErr := client.Billing.DeleteBillingProduct(
		context.TODO(),
		"billing_id",
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestBillingListProductPricesWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Get(gowiremock.URLPathTemplate("/billing/product/prices")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": []interface{}{map[string]interface{}{"currency": "currency", "external_price_id": "external_price_id", "id": "id", "interval": "interval", "price": 1, "price_decimal": "price_decimal", "scheme": "scheme"}}, "params": map[string]interface{}{"ids": []interface{}{"ids"}, "is_active": true, "limit": 1, "name": "name", "offset": 1, "price_usage_type": "licensed", "q": "q", "with_one_time_charges": true, "with_prices_only": true, "with_zero_price": true, "without_linked_to_plan": true}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.ListProductPricesRequest{
		Name: schematichq.String(
			"name",
		),
		Q: schematichq.String(
			"q",
		),
		PriceUsageType: schematichq.ListProductPricesRequestPriceUsageTypeLicensed.Ptr(),
		WithoutLinkedToPlan: schematichq.Bool(
			true,
		),
		WithOneTimeCharges: schematichq.Bool(
			true,
		),
		WithZeroPrice: schematichq.Bool(
			true,
		),
		WithPricesOnly: schematichq.Bool(
			true,
		),
		IsActive: schematichq.Bool(
			true,
		),
		Limit: schematichq.Int(
			1,
		),
		Offset: schematichq.Int(
			1,
		),
	}
	_, invocationErr := client.Billing.ListProductPrices(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestBillingDeleteProductPriceWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Delete(gowiremock.URLPathTemplate("/billing/product/prices/{billing_id}")).WithPathParam(
		"billing_id",
		gowiremock.Matching("billing_id"),
	).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": map[string]interface{}{"deleted": true}, "params": map[string]interface{}{"key": "value"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	_, invocationErr := client.Billing.DeleteProductPrice(
		context.TODO(),
		"billing_id",
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestBillingUpsertBillingProductWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Post(gowiremock.URLPathTemplate("/billing/product/upsert")).WithBodyPattern(gowiremock.MatchesJsonSchema(`{
                    "$schema": "https://json-schema.org/draft/2020-12/schema",
                    "type": "object",
                    "required": ["external_id", "name", "price"],
                    "properties": {
                        "external_id": {"type": "string"}, "name": {"type": "string"}, "price": {"type": "number"}
                    },
                    "additionalProperties": true
                }`, "V202012")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": map[string]interface{}{"account_id": "account_id", "created_at": "2024-01-15T09:30:00Z", "environment_id": "environment_id", "external_id": "external_id", "is_active": true, "name": "name", "price": 1.1, "price_decimal": "price_decimal", "product_id": "product_id", "quantity": 1.1, "updated_at": "2024-01-15T09:30:00Z"}, "params": map[string]interface{}{"key": "value"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.CreateBillingProductRequestBody{
		ExternalID: "external_id",
		Name:       "name",
		Price:      1.1,
	}
	_, invocationErr := client.Billing.UpsertBillingProduct(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestBillingListBillingProductsWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Get(gowiremock.URLPathTemplate("/billing/products")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": []interface{}{map[string]interface{}{"account_id": "account_id", "created_at": "2024-01-15T09:30:00Z", "environment_id": "environment_id", "external_id": "external_id", "is_active": true, "name": "name", "price": 1.1, "price_decimal": "price_decimal", "prices": []interface{}{map[string]interface{}{"currency": "currency", "external_price_id": "external_price_id", "id": "id", "interval": "interval", "price": 1, "scheme": "scheme"}}, "product_id": "product_id", "quantity": 1.1, "subscription_count": 1, "updated_at": "2024-01-15T09:30:00Z"}}, "params": map[string]interface{}{"ids": []interface{}{"ids"}, "is_active": true, "limit": 1, "name": "name", "offset": 1, "price_usage_type": "licensed", "q": "q", "with_one_time_charges": true, "with_prices_only": true, "with_zero_price": true, "without_linked_to_plan": true}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.ListBillingProductsRequest{
		Name: schematichq.String(
			"name",
		),
		Q: schematichq.String(
			"q",
		),
		PriceUsageType: schematichq.ListBillingProductsRequestPriceUsageTypeLicensed.Ptr(),
		WithoutLinkedToPlan: schematichq.Bool(
			true,
		),
		WithOneTimeCharges: schematichq.Bool(
			true,
		),
		WithZeroPrice: schematichq.Bool(
			true,
		),
		WithPricesOnly: schematichq.Bool(
			true,
		),
		IsActive: schematichq.Bool(
			true,
		),
		Limit: schematichq.Int(
			1,
		),
		Offset: schematichq.Int(
			1,
		),
	}
	_, invocationErr := client.Billing.ListBillingProducts(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestBillingCountBillingProductsWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Get(gowiremock.URLPathTemplate("/billing/products/count")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": map[string]interface{}{"count": 1}, "params": map[string]interface{}{"ids": []interface{}{"ids"}, "is_active": true, "limit": 1, "name": "name", "offset": 1, "price_usage_type": "licensed", "q": "q", "with_one_time_charges": true, "with_prices_only": true, "with_zero_price": true, "without_linked_to_plan": true}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.CountBillingProductsRequest{
		Name: schematichq.String(
			"name",
		),
		Q: schematichq.String(
			"q",
		),
		PriceUsageType: schematichq.CountBillingProductsRequestPriceUsageTypeLicensed.Ptr(),
		WithoutLinkedToPlan: schematichq.Bool(
			true,
		),
		WithOneTimeCharges: schematichq.Bool(
			true,
		),
		WithZeroPrice: schematichq.Bool(
			true,
		),
		WithPricesOnly: schematichq.Bool(
			true,
		),
		IsActive: schematichq.Bool(
			true,
		),
		Limit: schematichq.Int(
			1,
		),
		Offset: schematichq.Int(
			1,
		),
	}
	_, invocationErr := client.Billing.CountBillingProducts(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestBillingUpsertBillingSubscriptionWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Post(gowiremock.URLPathTemplate("/billing/subscription/upsert")).WithBodyPattern(gowiremock.MatchesJsonSchema(`{
                    "$schema": "https://json-schema.org/draft/2020-12/schema",
                    "type": "object",
                    "required": ["cancel_at_period_end", "currency", "customer_external_id", "discounts", "expired_at", "product_external_ids", "subscription_external_id", "total_price"],
                    "properties": {
                        "cancel_at_period_end": {"type": "boolean"}, "currency": {"type": "string"}, "customer_external_id": {"type": "string"}, "discounts": {"type": "array", "items": {"type": "object"}}, "expired_at": {"type": "string"}, "product_external_ids": {"type": "array", "items": {"type": "object"}}, "subscription_external_id": {"type": "string"}, "total_price": {"type": "integer"}
                    },
                    "additionalProperties": true
                }`, "V202012")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": map[string]interface{}{"cancel_at": 1, "cancel_at_period_end": true, "company_id": "company_id", "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "customer_external_id": "customer_external_id", "default_payment_method_id": "default_payment_method_id", "expired_at": "2024-01-15T09:30:00Z", "id": "id", "interval": "interval", "metadata": map[string]interface{}{"key": "value"}, "period_end": 1, "period_start": 1, "status": "status", "subscription_external_id": "subscription_external_id", "total_price": 1, "trial_end": 1, "trial_end_setting": "trial_end_setting"}, "params": map[string]interface{}{"key": "value"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.CreateBillingSubscriptionRequestBody{
		CancelAtPeriodEnd:  true,
		Currency:           "currency",
		CustomerExternalID: "customer_external_id",
		Discounts: []*schematichq.BillingSubscriptionDiscount{
			&schematichq.BillingSubscriptionDiscount{
				CouponExternalID: "coupon_external_id",
				ExternalID:       "external_id",
				IsActive:         true,
				StartedAt: schematichq.MustParseDateTime(
					"2024-01-15T09:30:00Z",
				),
			},
		},
		ExpiredAt: schematichq.MustParseDateTime(
			"2024-01-15T09:30:00Z",
		),
		ProductExternalIDs: []*schematichq.BillingProductPricing{
			&schematichq.BillingProductPricing{
				Currency:          "currency",
				Interval:          "interval",
				Price:             1,
				PriceExternalID:   "price_external_id",
				ProductExternalID: "product_external_id",
				Quantity:          1,
				UsageType:         schematichq.BillingProductPricingUsageTypeLicensed,
			},
		},
		SubscriptionExternalID: "subscription_external_id",
		TotalPrice:             1,
	}
	_, invocationErr := client.Billing.UpsertBillingSubscription(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}
