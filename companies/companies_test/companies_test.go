// Code generated by Fern. DO NOT EDIT.

package companies_test

import (
	context "context"
	fmt "fmt"
	schematicgo "github.com/SchematicHQ/schematic-go"
	client "github.com/SchematicHQ/schematic-go/client"
	option "github.com/SchematicHQ/schematic-go/option"
	require "github.com/stretchr/testify/require"
	gowiremock "github.com/wiremock/go-wiremock"
	wiremocktestcontainersgo "github.com/wiremock/wiremock-testcontainers-go"
	http "net/http"
	os "os"
	testing "testing"
)

// TestMain sets up shared test fixtures for all tests in this package// Global test fixtures
var (
	WireMockContainer *wiremocktestcontainersgo.WireMockContainer
	WireMockBaseURL   string
	WireMockClient    *gowiremock.Client
)

// TestMain sets up shared test fixtures for all tests in this package
func TestMain(m *testing.M) {
	// Setup shared WireMock container
	ctx := context.Background()
	container, err := wiremocktestcontainersgo.RunContainerAndStopOnCleanup(
		ctx,
		&testing.T{},
		wiremocktestcontainersgo.WithImage("docker.io/wiremock/wiremock:3.9.1"),
	)
	if err != nil {
		fmt.Printf("Failed to start WireMock container: %v\n", err)
		os.Exit(1)
	}

	// Store global references
	WireMockContainer = container

	// Try to get the base URL using the standard method first
	baseURL, err := container.Endpoint(ctx, "")
	if err == nil {
		// Standard method worked (running outside DinD)
		// This uses the mapped port (e.g., localhost:59553)
		WireMockBaseURL = "http://" + baseURL
		WireMockClient = container.Client
	} else {
		// Standard method failed, use internal IP fallback (DinD environment)
		fmt.Printf("Standard endpoint resolution failed, using internal IP fallback: %v\n", err)

		inspect, err := container.Inspect(ctx)
		if err != nil {
			fmt.Printf("Failed to inspect WireMock container: %v\n", err)
			os.Exit(1)
		}

		// Find the IP address from the container's networks
		var containerIP string
		for _, network := range inspect.NetworkSettings.Networks {
			if network.IPAddress != "" {
				containerIP = network.IPAddress
				break
			}
		}

		if containerIP == "" {
			fmt.Printf("Failed to get WireMock container IP address\n")
			os.Exit(1)
		}

		// In DinD, use the internal port directly (8080 for WireMock HTTP)
		// Don't use the mapped port since it doesn't exist in this environment
		WireMockBaseURL = fmt.Sprintf("http://%s:8080", containerIP)

		// The container.Client was created with a bad URL, so we need a new one
		WireMockClient = gowiremock.NewClient(WireMockBaseURL)
	}

	fmt.Printf("WireMock available at: %s\n", WireMockBaseURL)

	// Run all tests
	code := m.Run()

	// Cleanup
	if WireMockContainer != nil {
		WireMockContainer.Terminate(ctx)
	}

	// Exit with the same code as the tests
	os.Exit(code)
}

func TestCompaniesListCompaniesWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Get(gowiremock.URLPathTemplate("/companies")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": []interface{}{map[string]interface{}{"add_ons": []interface{}{map[string]interface{}{"id": "id", "name": "name"}}, "billing_credit_balances": map[string]interface{}{"key": 1.1}, "billing_subscription": map[string]interface{}{"cancel_at_period_end": true, "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "customer_external_id": "customer_external_id", "discounts": []interface{}{map[string]interface{}{"coupon_id": "coupon_id", "coupon_name": "coupon_name", "discount_external_id": "discount_external_id", "duration": "duration", "is_active": true, "started_at": "2024-01-15T09:30:00Z", "subscription_external_id": "subscription_external_id"}}, "id": "id", "interval": "interval", "period_end": 1, "period_start": 1, "products": []interface{}{map[string]interface{}{"billing_scheme": "billing_scheme", "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "interval": "interval", "name": "name", "package_size": 1, "price": 1, "price_external_id": "price_external_id", "price_id": "price_id", "price_tier": []interface{}{map[string]interface{}{}}, "quantity": 1.1, "subscription_id": "subscription_id", "updated_at": "2024-01-15T09:30:00Z", "usage_type": "usage_type"}}, "status": "status", "subscription_external_id": "subscription_external_id", "total_price": 1}, "billing_subscriptions": []interface{}{map[string]interface{}{"cancel_at_period_end": true, "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "customer_external_id": "customer_external_id", "discounts": []interface{}{map[string]interface{}{"coupon_id": "coupon_id", "coupon_name": "coupon_name", "discount_external_id": "discount_external_id", "duration": "duration", "is_active": true, "started_at": "2024-01-15T09:30:00Z", "subscription_external_id": "subscription_external_id"}}, "id": "id", "interval": "interval", "period_end": 1, "period_start": 1, "products": []interface{}{map[string]interface{}{"billing_scheme": "billing_scheme", "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "interval": "interval", "name": "name", "package_size": 1, "price": 1, "price_external_id": "price_external_id", "price_id": "price_id", "price_tier": []interface{}{map[string]interface{}{}}, "quantity": 1.1, "subscription_id": "subscription_id", "updated_at": "2024-01-15T09:30:00Z", "usage_type": "usage_type"}}, "status": "status", "subscription_external_id": "subscription_external_id", "total_price": 1}}, "created_at": "2024-01-15T09:30:00Z", "default_payment_method": map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "customer_external_id": "customer_external_id", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "payment_method_type": "payment_method_type", "updated_at": "2024-01-15T09:30:00Z"}, "entity_traits": []interface{}{map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "definition_id": "definition_id", "environment_id": "environment_id", "id": "id", "updated_at": "2024-01-15T09:30:00Z", "value": "value"}}, "environment_id": "environment_id", "id": "id", "keys": []interface{}{map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "definition_id": "definition_id", "entity_id": "entity_id", "entity_type": "entity_type", "environment_id": "environment_id", "id": "id", "key": "key", "updated_at": "2024-01-15T09:30:00Z", "value": "value"}}, "last_seen_at": "2024-01-15T09:30:00Z", "logo_url": "logo_url", "metrics": []interface{}{map[string]interface{}{"account_id": "account_id", "captured_at_max": "2024-01-15T09:30:00Z", "captured_at_min": "2024-01-15T09:30:00Z", "company_id": "company_id", "created_at": "2024-01-15T09:30:00Z", "environment_id": "environment_id", "event_subtype": "event_subtype", "month_reset": "month_reset", "period": "period", "value": 1}}, "name": "name", "payment_methods": []interface{}{map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "customer_external_id": "customer_external_id", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "payment_method_type": "payment_method_type", "updated_at": "2024-01-15T09:30:00Z"}}, "plan": map[string]interface{}{"id": "id", "name": "name"}, "plans": []interface{}{map[string]interface{}{"id": "id", "name": "name"}}, "rules": []interface{}{map[string]interface{}{"account_id": "account_id", "condition_groups": []interface{}{map[string]interface{}{"conditions": []interface{}{map[string]interface{}{"account_id": "account_id", "condition_type": "base_plan", "environment_id": "environment_id", "id": "id", "operator": "eq", "resource_ids": []interface{}{"resource_ids"}, "trait_value": "trait_value"}}}}, "conditions": []interface{}{map[string]interface{}{"account_id": "account_id", "condition_type": "base_plan", "environment_id": "environment_id", "id": "id", "operator": "eq", "resource_ids": []interface{}{"resource_ids"}, "trait_value": "trait_value"}}, "environment_id": "environment_id", "id": "id", "name": "name", "priority": 1, "rule_type": "default", "value": true}}, "traits": map[string]interface{}{"key": "value"}, "updated_at": "2024-01-15T09:30:00Z", "user_count": 1}}, "params": map[string]interface{}{"ids": []interface{}{"ids"}, "limit": 1, "offset": 1, "plan_id": "plan_id", "q": "q", "with_subscription": true, "without_feature_override_for": "without_feature_override_for", "without_plan": true}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.ListCompaniesRequest{
		PlanID: schematichq.String(
			"plan_id",
		),
		Q: schematichq.String(
			"q",
		),
		WithoutFeatureOverrideFor: schematichq.String(
			"without_feature_override_for",
		),
		WithoutPlan: schematichq.Bool(
			true,
		),
		WithSubscription: schematichq.Bool(
			true,
		),
		Limit: schematichq.Int(
			1,
		),
		Offset: schematichq.Int(
			1,
		),
	}
	_, invocationErr := client.Companies.ListCompanies(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestCompaniesUpsertCompanyWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Post(gowiremock.URLPathTemplate("/companies")).WithBodyPattern(gowiremock.MatchesJsonSchema("{}", "V202012")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": map[string]interface{}{"add_ons": []interface{}{map[string]interface{}{"id": "id", "name": "name"}}, "billing_credit_balances": map[string]interface{}{"key": 1.1}, "billing_subscription": map[string]interface{}{"cancel_at": 1, "cancel_at_period_end": true, "company_id": "company_id", "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "customer_external_id": "customer_external_id", "default_payment_method_id": "default_payment_method_id", "discounts": []interface{}{map[string]interface{}{"coupon_id": "coupon_id", "coupon_name": "coupon_name", "discount_external_id": "discount_external_id", "duration": "duration", "is_active": true, "started_at": "2024-01-15T09:30:00Z", "subscription_external_id": "subscription_external_id"}}, "expired_at": "2024-01-15T09:30:00Z", "id": "id", "interval": "interval", "latest_invoice": map[string]interface{}{"amount_due": 1, "amount_paid": 1, "amount_remaining": 1, "collection_method": "collection_method", "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "customer_external_id": "customer_external_id", "environment_id": "environment_id", "id": "id", "subtotal": 1, "updated_at": "2024-01-15T09:30:00Z"}, "metadata": map[string]interface{}{"key": "value"}, "payment_method": map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "customer_external_id": "customer_external_id", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "payment_method_type": "payment_method_type", "updated_at": "2024-01-15T09:30:00Z"}, "period_end": 1, "period_start": 1, "products": []interface{}{map[string]interface{}{"billing_scheme": "billing_scheme", "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "interval": "interval", "name": "name", "package_size": 1, "price": 1, "price_external_id": "price_external_id", "price_id": "price_id", "price_tier": []interface{}{map[string]interface{}{}}, "quantity": 1.1, "subscription_id": "subscription_id", "updated_at": "2024-01-15T09:30:00Z", "usage_type": "usage_type"}}, "status": "status", "subscription_external_id": "subscription_external_id", "total_price": 1, "trial_end": 1, "trial_end_setting": "trial_end_setting"}, "billing_subscriptions": []interface{}{map[string]interface{}{"cancel_at_period_end": true, "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "customer_external_id": "customer_external_id", "discounts": []interface{}{map[string]interface{}{"coupon_id": "coupon_id", "coupon_name": "coupon_name", "discount_external_id": "discount_external_id", "duration": "duration", "is_active": true, "started_at": "2024-01-15T09:30:00Z", "subscription_external_id": "subscription_external_id"}}, "id": "id", "interval": "interval", "period_end": 1, "period_start": 1, "products": []interface{}{map[string]interface{}{"billing_scheme": "billing_scheme", "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "interval": "interval", "name": "name", "package_size": 1, "price": 1, "price_external_id": "price_external_id", "price_id": "price_id", "price_tier": []interface{}{map[string]interface{}{}}, "quantity": 1.1, "subscription_id": "subscription_id", "updated_at": "2024-01-15T09:30:00Z", "usage_type": "usage_type"}}, "status": "status", "subscription_external_id": "subscription_external_id", "total_price": 1}}, "created_at": "2024-01-15T09:30:00Z", "default_payment_method": map[string]interface{}{"account_last4": "account_last4", "account_name": "account_name", "bank_name": "bank_name", "billing_email": "billing_email", "billing_name": "billing_name", "card_brand": "card_brand", "card_exp_month": 1, "card_exp_year": 1, "card_last4": "card_last4", "company_id": "company_id", "created_at": "2024-01-15T09:30:00Z", "customer_external_id": "customer_external_id", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "payment_method_type": "payment_method_type", "updated_at": "2024-01-15T09:30:00Z"}, "entity_traits": []interface{}{map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "definition_id": "definition_id", "environment_id": "environment_id", "id": "id", "updated_at": "2024-01-15T09:30:00Z", "value": "value"}}, "environment_id": "environment_id", "id": "id", "keys": []interface{}{map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "definition_id": "definition_id", "entity_id": "entity_id", "entity_type": "entity_type", "environment_id": "environment_id", "id": "id", "key": "key", "updated_at": "2024-01-15T09:30:00Z", "value": "value"}}, "last_seen_at": "2024-01-15T09:30:00Z", "logo_url": "logo_url", "metrics": []interface{}{map[string]interface{}{"account_id": "account_id", "captured_at_max": "2024-01-15T09:30:00Z", "captured_at_min": "2024-01-15T09:30:00Z", "company_id": "company_id", "created_at": "2024-01-15T09:30:00Z", "environment_id": "environment_id", "event_subtype": "event_subtype", "month_reset": "month_reset", "period": "period", "value": 1}}, "name": "name", "payment_methods": []interface{}{map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "customer_external_id": "customer_external_id", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "payment_method_type": "payment_method_type", "updated_at": "2024-01-15T09:30:00Z"}}, "plan": map[string]interface{}{"added_on": "2024-01-15T09:30:00Z", "billing_product_external_id": "billing_product_external_id", "billing_product_id": "billing_product_id", "description": "description", "id": "id", "image_url": "image_url", "name": "name", "plan_period": "plan_period", "plan_price": 1}, "plans": []interface{}{map[string]interface{}{"id": "id", "name": "name"}}, "rules": []interface{}{map[string]interface{}{"account_id": "account_id", "condition_groups": []interface{}{map[string]interface{}{"conditions": []interface{}{map[string]interface{}{"account_id": "account_id", "condition_type": "base_plan", "environment_id": "environment_id", "id": "id", "operator": "eq", "resource_ids": []interface{}{"resource_ids"}, "trait_value": "trait_value"}}}}, "conditions": []interface{}{map[string]interface{}{"account_id": "account_id", "condition_type": "base_plan", "environment_id": "environment_id", "id": "id", "operator": "eq", "resource_ids": []interface{}{"resource_ids"}, "trait_value": "trait_value"}}, "environment_id": "environment_id", "id": "id", "name": "name", "priority": 1, "rule_type": "default", "value": true}}, "traits": map[string]interface{}{"key": "value"}, "updated_at": "2024-01-15T09:30:00Z", "user_count": 1}, "params": map[string]interface{}{"key": "value"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.UpsertCompanyRequestBody{
		Keys: map[string]string{
			"key": "value",
		},
	}
	_, invocationErr := client.Companies.UpsertCompany(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestCompaniesGetCompanyWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Get(gowiremock.URLPathTemplate("/companies/{company_id}")).WithPathParam(
		"company_id",
		gowiremock.Matching("company_id"),
	).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": map[string]interface{}{"add_ons": []interface{}{map[string]interface{}{"id": "id", "name": "name"}}, "billing_credit_balances": map[string]interface{}{"key": 1.1}, "billing_subscription": map[string]interface{}{"cancel_at": 1, "cancel_at_period_end": true, "company_id": "company_id", "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "customer_external_id": "customer_external_id", "default_payment_method_id": "default_payment_method_id", "discounts": []interface{}{map[string]interface{}{"coupon_id": "coupon_id", "coupon_name": "coupon_name", "discount_external_id": "discount_external_id", "duration": "duration", "is_active": true, "started_at": "2024-01-15T09:30:00Z", "subscription_external_id": "subscription_external_id"}}, "expired_at": "2024-01-15T09:30:00Z", "id": "id", "interval": "interval", "latest_invoice": map[string]interface{}{"amount_due": 1, "amount_paid": 1, "amount_remaining": 1, "collection_method": "collection_method", "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "customer_external_id": "customer_external_id", "environment_id": "environment_id", "id": "id", "subtotal": 1, "updated_at": "2024-01-15T09:30:00Z"}, "metadata": map[string]interface{}{"key": "value"}, "payment_method": map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "customer_external_id": "customer_external_id", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "payment_method_type": "payment_method_type", "updated_at": "2024-01-15T09:30:00Z"}, "period_end": 1, "period_start": 1, "products": []interface{}{map[string]interface{}{"billing_scheme": "billing_scheme", "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "interval": "interval", "name": "name", "package_size": 1, "price": 1, "price_external_id": "price_external_id", "price_id": "price_id", "price_tier": []interface{}{map[string]interface{}{}}, "quantity": 1.1, "subscription_id": "subscription_id", "updated_at": "2024-01-15T09:30:00Z", "usage_type": "usage_type"}}, "status": "status", "subscription_external_id": "subscription_external_id", "total_price": 1, "trial_end": 1, "trial_end_setting": "trial_end_setting"}, "billing_subscriptions": []interface{}{map[string]interface{}{"cancel_at_period_end": true, "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "customer_external_id": "customer_external_id", "discounts": []interface{}{map[string]interface{}{"coupon_id": "coupon_id", "coupon_name": "coupon_name", "discount_external_id": "discount_external_id", "duration": "duration", "is_active": true, "started_at": "2024-01-15T09:30:00Z", "subscription_external_id": "subscription_external_id"}}, "id": "id", "interval": "interval", "period_end": 1, "period_start": 1, "products": []interface{}{map[string]interface{}{"billing_scheme": "billing_scheme", "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "interval": "interval", "name": "name", "package_size": 1, "price": 1, "price_external_id": "price_external_id", "price_id": "price_id", "price_tier": []interface{}{map[string]interface{}{}}, "quantity": 1.1, "subscription_id": "subscription_id", "updated_at": "2024-01-15T09:30:00Z", "usage_type": "usage_type"}}, "status": "status", "subscription_external_id": "subscription_external_id", "total_price": 1}}, "created_at": "2024-01-15T09:30:00Z", "default_payment_method": map[string]interface{}{"account_last4": "account_last4", "account_name": "account_name", "bank_name": "bank_name", "billing_email": "billing_email", "billing_name": "billing_name", "card_brand": "card_brand", "card_exp_month": 1, "card_exp_year": 1, "card_last4": "card_last4", "company_id": "company_id", "created_at": "2024-01-15T09:30:00Z", "customer_external_id": "customer_external_id", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "payment_method_type": "payment_method_type", "updated_at": "2024-01-15T09:30:00Z"}, "entity_traits": []interface{}{map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "definition_id": "definition_id", "environment_id": "environment_id", "id": "id", "updated_at": "2024-01-15T09:30:00Z", "value": "value"}}, "environment_id": "environment_id", "id": "id", "keys": []interface{}{map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "definition_id": "definition_id", "entity_id": "entity_id", "entity_type": "entity_type", "environment_id": "environment_id", "id": "id", "key": "key", "updated_at": "2024-01-15T09:30:00Z", "value": "value"}}, "last_seen_at": "2024-01-15T09:30:00Z", "logo_url": "logo_url", "metrics": []interface{}{map[string]interface{}{"account_id": "account_id", "captured_at_max": "2024-01-15T09:30:00Z", "captured_at_min": "2024-01-15T09:30:00Z", "company_id": "company_id", "created_at": "2024-01-15T09:30:00Z", "environment_id": "environment_id", "event_subtype": "event_subtype", "month_reset": "month_reset", "period": "period", "value": 1}}, "name": "name", "payment_methods": []interface{}{map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "customer_external_id": "customer_external_id", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "payment_method_type": "payment_method_type", "updated_at": "2024-01-15T09:30:00Z"}}, "plan": map[string]interface{}{"added_on": "2024-01-15T09:30:00Z", "billing_product_external_id": "billing_product_external_id", "billing_product_id": "billing_product_id", "description": "description", "id": "id", "image_url": "image_url", "name": "name", "plan_period": "plan_period", "plan_price": 1}, "plans": []interface{}{map[string]interface{}{"id": "id", "name": "name"}}, "rules": []interface{}{map[string]interface{}{"account_id": "account_id", "condition_groups": []interface{}{map[string]interface{}{"conditions": []interface{}{map[string]interface{}{"account_id": "account_id", "condition_type": "base_plan", "environment_id": "environment_id", "id": "id", "operator": "eq", "resource_ids": []interface{}{"resource_ids"}, "trait_value": "trait_value"}}}}, "conditions": []interface{}{map[string]interface{}{"account_id": "account_id", "condition_type": "base_plan", "environment_id": "environment_id", "id": "id", "operator": "eq", "resource_ids": []interface{}{"resource_ids"}, "trait_value": "trait_value"}}, "environment_id": "environment_id", "id": "id", "name": "name", "priority": 1, "rule_type": "default", "value": true}}, "traits": map[string]interface{}{"key": "value"}, "updated_at": "2024-01-15T09:30:00Z", "user_count": 1}, "params": map[string]interface{}{"key": "value"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	_, invocationErr := client.Companies.GetCompany(
		context.TODO(),
		"company_id",
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestCompaniesDeleteCompanyWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Delete(gowiremock.URLPathTemplate("/companies/{company_id}")).WithPathParam(
		"company_id",
		gowiremock.Matching("company_id"),
	).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": map[string]interface{}{"deleted": true}, "params": map[string]interface{}{"cancel_subscription": true, "prorate": true}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.DeleteCompanyRequest{
		CancelSubscription: schematichq.Bool(
			true,
		),
		Prorate: schematichq.Bool(
			true,
		),
	}
	_, invocationErr := client.Companies.DeleteCompany(
		context.TODO(),
		"company_id",
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestCompaniesCountCompaniesWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Get(gowiremock.URLPathTemplate("/companies/count")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": map[string]interface{}{"count": 1}, "params": map[string]interface{}{"ids": []interface{}{"ids"}, "limit": 1, "offset": 1, "plan_id": "plan_id", "q": "q", "with_subscription": true, "without_feature_override_for": "without_feature_override_for", "without_plan": true}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.CountCompaniesRequest{
		PlanID: schematichq.String(
			"plan_id",
		),
		Q: schematichq.String(
			"q",
		),
		WithoutFeatureOverrideFor: schematichq.String(
			"without_feature_override_for",
		),
		WithoutPlan: schematichq.Bool(
			true,
		),
		WithSubscription: schematichq.Bool(
			true,
		),
		Limit: schematichq.Int(
			1,
		),
		Offset: schematichq.Int(
			1,
		),
	}
	_, invocationErr := client.Companies.CountCompanies(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestCompaniesCountCompaniesForAdvancedFilterWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Get(gowiremock.URLPathTemplate("/companies/count2")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": map[string]interface{}{"count": 1}, "params": map[string]interface{}{"credit_type_ids": []interface{}{"credit_type_ids"}, "display_properties": []interface{}{"display_properties"}, "feature_ids": []interface{}{"feature_ids"}, "ids": []interface{}{"ids"}, "limit": 1, "monetized_subscriptions": true, "offset": 1, "plan_ids": []interface{}{"plan_ids"}, "q": "q", "sort_order_column": "sort_order_column", "sort_order_direction": "asc", "subscription_statuses": []interface{}{"subscription_statuses"}, "subscription_types": []interface{}{"subscription_types"}, "without_plan": true, "without_subscription": true}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.CountCompaniesForAdvancedFilterRequest{
		MonetizedSubscriptions: schematichq.Bool(
			true,
		),
		Q: schematichq.String(
			"q",
		),
		WithoutPlan: schematichq.Bool(
			true,
		),
		WithoutSubscription: schematichq.Bool(
			true,
		),
		SortOrderColumn: schematichq.String(
			"sort_order_column",
		),
		SortOrderDirection: schematichq.CountCompaniesForAdvancedFilterRequestSortOrderDirectionAsc.Ptr(),
		Limit: schematichq.Int(
			1,
		),
		Offset: schematichq.Int(
			1,
		),
	}
	_, invocationErr := client.Companies.CountCompaniesForAdvancedFilter(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestCompaniesCreateCompanyWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Post(gowiremock.URLPathTemplate("/companies/create")).WithBodyPattern(gowiremock.MatchesJsonSchema("{}", "V202012")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": map[string]interface{}{"add_ons": []interface{}{map[string]interface{}{"id": "id", "name": "name"}}, "billing_credit_balances": map[string]interface{}{"key": 1.1}, "billing_subscription": map[string]interface{}{"cancel_at": 1, "cancel_at_period_end": true, "company_id": "company_id", "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "customer_external_id": "customer_external_id", "default_payment_method_id": "default_payment_method_id", "discounts": []interface{}{map[string]interface{}{"coupon_id": "coupon_id", "coupon_name": "coupon_name", "discount_external_id": "discount_external_id", "duration": "duration", "is_active": true, "started_at": "2024-01-15T09:30:00Z", "subscription_external_id": "subscription_external_id"}}, "expired_at": "2024-01-15T09:30:00Z", "id": "id", "interval": "interval", "latest_invoice": map[string]interface{}{"amount_due": 1, "amount_paid": 1, "amount_remaining": 1, "collection_method": "collection_method", "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "customer_external_id": "customer_external_id", "environment_id": "environment_id", "id": "id", "subtotal": 1, "updated_at": "2024-01-15T09:30:00Z"}, "metadata": map[string]interface{}{"key": "value"}, "payment_method": map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "customer_external_id": "customer_external_id", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "payment_method_type": "payment_method_type", "updated_at": "2024-01-15T09:30:00Z"}, "period_end": 1, "period_start": 1, "products": []interface{}{map[string]interface{}{"billing_scheme": "billing_scheme", "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "interval": "interval", "name": "name", "package_size": 1, "price": 1, "price_external_id": "price_external_id", "price_id": "price_id", "price_tier": []interface{}{map[string]interface{}{}}, "quantity": 1.1, "subscription_id": "subscription_id", "updated_at": "2024-01-15T09:30:00Z", "usage_type": "usage_type"}}, "status": "status", "subscription_external_id": "subscription_external_id", "total_price": 1, "trial_end": 1, "trial_end_setting": "trial_end_setting"}, "billing_subscriptions": []interface{}{map[string]interface{}{"cancel_at_period_end": true, "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "customer_external_id": "customer_external_id", "discounts": []interface{}{map[string]interface{}{"coupon_id": "coupon_id", "coupon_name": "coupon_name", "discount_external_id": "discount_external_id", "duration": "duration", "is_active": true, "started_at": "2024-01-15T09:30:00Z", "subscription_external_id": "subscription_external_id"}}, "id": "id", "interval": "interval", "period_end": 1, "period_start": 1, "products": []interface{}{map[string]interface{}{"billing_scheme": "billing_scheme", "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "interval": "interval", "name": "name", "package_size": 1, "price": 1, "price_external_id": "price_external_id", "price_id": "price_id", "price_tier": []interface{}{map[string]interface{}{}}, "quantity": 1.1, "subscription_id": "subscription_id", "updated_at": "2024-01-15T09:30:00Z", "usage_type": "usage_type"}}, "status": "status", "subscription_external_id": "subscription_external_id", "total_price": 1}}, "created_at": "2024-01-15T09:30:00Z", "default_payment_method": map[string]interface{}{"account_last4": "account_last4", "account_name": "account_name", "bank_name": "bank_name", "billing_email": "billing_email", "billing_name": "billing_name", "card_brand": "card_brand", "card_exp_month": 1, "card_exp_year": 1, "card_last4": "card_last4", "company_id": "company_id", "created_at": "2024-01-15T09:30:00Z", "customer_external_id": "customer_external_id", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "payment_method_type": "payment_method_type", "updated_at": "2024-01-15T09:30:00Z"}, "entity_traits": []interface{}{map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "definition_id": "definition_id", "environment_id": "environment_id", "id": "id", "updated_at": "2024-01-15T09:30:00Z", "value": "value"}}, "environment_id": "environment_id", "id": "id", "keys": []interface{}{map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "definition_id": "definition_id", "entity_id": "entity_id", "entity_type": "entity_type", "environment_id": "environment_id", "id": "id", "key": "key", "updated_at": "2024-01-15T09:30:00Z", "value": "value"}}, "last_seen_at": "2024-01-15T09:30:00Z", "logo_url": "logo_url", "metrics": []interface{}{map[string]interface{}{"account_id": "account_id", "captured_at_max": "2024-01-15T09:30:00Z", "captured_at_min": "2024-01-15T09:30:00Z", "company_id": "company_id", "created_at": "2024-01-15T09:30:00Z", "environment_id": "environment_id", "event_subtype": "event_subtype", "month_reset": "month_reset", "period": "period", "value": 1}}, "name": "name", "payment_methods": []interface{}{map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "customer_external_id": "customer_external_id", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "payment_method_type": "payment_method_type", "updated_at": "2024-01-15T09:30:00Z"}}, "plan": map[string]interface{}{"added_on": "2024-01-15T09:30:00Z", "billing_product_external_id": "billing_product_external_id", "billing_product_id": "billing_product_id", "description": "description", "id": "id", "image_url": "image_url", "name": "name", "plan_period": "plan_period", "plan_price": 1}, "plans": []interface{}{map[string]interface{}{"id": "id", "name": "name"}}, "rules": []interface{}{map[string]interface{}{"account_id": "account_id", "condition_groups": []interface{}{map[string]interface{}{"conditions": []interface{}{map[string]interface{}{"account_id": "account_id", "condition_type": "base_plan", "environment_id": "environment_id", "id": "id", "operator": "eq", "resource_ids": []interface{}{"resource_ids"}, "trait_value": "trait_value"}}}}, "conditions": []interface{}{map[string]interface{}{"account_id": "account_id", "condition_type": "base_plan", "environment_id": "environment_id", "id": "id", "operator": "eq", "resource_ids": []interface{}{"resource_ids"}, "trait_value": "trait_value"}}, "environment_id": "environment_id", "id": "id", "name": "name", "priority": 1, "rule_type": "default", "value": true}}, "traits": map[string]interface{}{"key": "value"}, "updated_at": "2024-01-15T09:30:00Z", "user_count": 1}, "params": map[string]interface{}{"key": "value"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.UpsertCompanyRequestBody{
		Keys: map[string]string{
			"key": "value",
		},
	}
	_, invocationErr := client.Companies.CreateCompany(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestCompaniesDeleteCompanyByKeysWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Post(gowiremock.URLPathTemplate("/companies/delete")).WithBodyPattern(gowiremock.MatchesJsonSchema("{}", "V202012")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "environment_id": "environment_id", "id": "id", "last_seen_at": "2024-01-15T09:30:00Z", "logo_url": "logo_url", "name": "name", "updated_at": "2024-01-15T09:30:00Z"}, "params": map[string]interface{}{"key": "value"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.KeysRequestBody{
		Keys: map[string]string{
			"key": "value",
		},
	}
	_, invocationErr := client.Companies.DeleteCompanyByKeys(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestCompaniesListCompaniesForAdvancedFilterWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Get(gowiremock.URLPathTemplate("/companies/list2")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": []interface{}{map[string]interface{}{"add_ons": []interface{}{map[string]interface{}{"id": "id", "name": "name"}}, "billing_credit_balances": map[string]interface{}{"key": 1.1}, "billing_subscription": map[string]interface{}{"cancel_at_period_end": true, "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "customer_external_id": "customer_external_id", "discounts": []interface{}{map[string]interface{}{"coupon_id": "coupon_id", "coupon_name": "coupon_name", "discount_external_id": "discount_external_id", "duration": "duration", "is_active": true, "started_at": "2024-01-15T09:30:00Z", "subscription_external_id": "subscription_external_id"}}, "id": "id", "interval": "interval", "period_end": 1, "period_start": 1, "products": []interface{}{map[string]interface{}{"billing_scheme": "billing_scheme", "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "interval": "interval", "name": "name", "package_size": 1, "price": 1, "price_external_id": "price_external_id", "price_id": "price_id", "price_tier": []interface{}{map[string]interface{}{}}, "quantity": 1.1, "subscription_id": "subscription_id", "updated_at": "2024-01-15T09:30:00Z", "usage_type": "usage_type"}}, "status": "status", "subscription_external_id": "subscription_external_id", "total_price": 1}, "billing_subscriptions": []interface{}{map[string]interface{}{"cancel_at_period_end": true, "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "customer_external_id": "customer_external_id", "discounts": []interface{}{map[string]interface{}{"coupon_id": "coupon_id", "coupon_name": "coupon_name", "discount_external_id": "discount_external_id", "duration": "duration", "is_active": true, "started_at": "2024-01-15T09:30:00Z", "subscription_external_id": "subscription_external_id"}}, "id": "id", "interval": "interval", "period_end": 1, "period_start": 1, "products": []interface{}{map[string]interface{}{"billing_scheme": "billing_scheme", "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "interval": "interval", "name": "name", "package_size": 1, "price": 1, "price_external_id": "price_external_id", "price_id": "price_id", "price_tier": []interface{}{map[string]interface{}{}}, "quantity": 1.1, "subscription_id": "subscription_id", "updated_at": "2024-01-15T09:30:00Z", "usage_type": "usage_type"}}, "status": "status", "subscription_external_id": "subscription_external_id", "total_price": 1}}, "created_at": "2024-01-15T09:30:00Z", "default_payment_method": map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "customer_external_id": "customer_external_id", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "payment_method_type": "payment_method_type", "updated_at": "2024-01-15T09:30:00Z"}, "entity_traits": []interface{}{map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "definition_id": "definition_id", "environment_id": "environment_id", "id": "id", "updated_at": "2024-01-15T09:30:00Z", "value": "value"}}, "environment_id": "environment_id", "feature_usage": []interface{}{map[string]interface{}{"entitlement_source": "entitlement_source", "entitlement_value_type": "entitlement_value_type", "feature_id": "feature_id", "feature_name": "feature_name", "feature_type": "feature_type", "hard_limit": "hard_limit", "has_access": true, "soft_limit": "soft_limit", "usage": "usage"}}, "id": "id", "keys": []interface{}{map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "definition_id": "definition_id", "entity_id": "entity_id", "entity_type": "entity_type", "environment_id": "environment_id", "id": "id", "key": "key", "updated_at": "2024-01-15T09:30:00Z", "value": "value"}}, "last_seen_at": "2024-01-15T09:30:00Z", "logo_url": "logo_url", "metrics": []interface{}{map[string]interface{}{"account_id": "account_id", "captured_at_max": "2024-01-15T09:30:00Z", "captured_at_min": "2024-01-15T09:30:00Z", "company_id": "company_id", "created_at": "2024-01-15T09:30:00Z", "environment_id": "environment_id", "event_subtype": "event_subtype", "month_reset": "month_reset", "period": "period", "value": 1}}, "name": "name", "payment_methods": []interface{}{map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "customer_external_id": "customer_external_id", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "payment_method_type": "payment_method_type", "updated_at": "2024-01-15T09:30:00Z"}}, "plan": map[string]interface{}{"id": "id", "name": "name"}, "plans": []interface{}{map[string]interface{}{"id": "id", "name": "name"}}, "rules": []interface{}{map[string]interface{}{"account_id": "account_id", "condition_groups": []interface{}{map[string]interface{}{"conditions": []interface{}{map[string]interface{}{"account_id": "account_id", "condition_type": "base_plan", "environment_id": "environment_id", "id": "id", "operator": "eq", "resource_ids": []interface{}{"resource_ids"}, "trait_value": "trait_value"}}}}, "conditions": []interface{}{map[string]interface{}{"account_id": "account_id", "condition_type": "base_plan", "environment_id": "environment_id", "id": "id", "operator": "eq", "resource_ids": []interface{}{"resource_ids"}, "trait_value": "trait_value"}}, "environment_id": "environment_id", "id": "id", "name": "name", "priority": 1, "rule_type": "default", "value": true}}, "traits": map[string]interface{}{"key": "value"}, "updated_at": "2024-01-15T09:30:00Z", "user_count": 1}}, "params": map[string]interface{}{"credit_type_ids": []interface{}{"credit_type_ids"}, "display_properties": []interface{}{"display_properties"}, "feature_ids": []interface{}{"feature_ids"}, "ids": []interface{}{"ids"}, "limit": 1, "monetized_subscriptions": true, "offset": 1, "plan_ids": []interface{}{"plan_ids"}, "q": "q", "sort_order_column": "sort_order_column", "sort_order_direction": "asc", "subscription_statuses": []interface{}{"subscription_statuses"}, "subscription_types": []interface{}{"subscription_types"}, "without_plan": true, "without_subscription": true}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.ListCompaniesForAdvancedFilterRequest{
		MonetizedSubscriptions: schematichq.Bool(
			true,
		),
		Q: schematichq.String(
			"q",
		),
		WithoutPlan: schematichq.Bool(
			true,
		),
		WithoutSubscription: schematichq.Bool(
			true,
		),
		SortOrderColumn: schematichq.String(
			"sort_order_column",
		),
		SortOrderDirection: schematichq.ListCompaniesForAdvancedFilterRequestSortOrderDirectionAsc.Ptr(),
		Limit: schematichq.Int(
			1,
		),
		Offset: schematichq.Int(
			1,
		),
	}
	_, invocationErr := client.Companies.ListCompaniesForAdvancedFilter(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestCompaniesLookupCompanyWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Get(gowiremock.URLPathTemplate("/companies/lookup")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": map[string]interface{}{"add_ons": []interface{}{map[string]interface{}{"added_on": "2024-01-15T09:30:00Z", "billing_product_external_id": "billing_product_external_id", "billing_product_id": "billing_product_id", "description": "description", "id": "id", "image_url": "image_url", "name": "name", "plan_period": "plan_period", "plan_price": 1}, map[string]interface{}{"added_on": "2024-01-15T09:30:00Z", "billing_product_external_id": "billing_product_external_id", "billing_product_id": "billing_product_id", "description": "description", "id": "id", "image_url": "image_url", "name": "name", "plan_period": "plan_period", "plan_price": 1}}, "billing_credit_balances": map[string]interface{}{"billing_credit_balances": 1.1}, "billing_subscription": map[string]interface{}{"cancel_at": 1, "cancel_at_period_end": true, "company_id": "company_id", "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "customer_external_id": "customer_external_id", "default_payment_method_id": "default_payment_method_id", "discounts": []interface{}{map[string]interface{}{"amount_off": 1, "coupon_id": "coupon_id", "coupon_name": "coupon_name", "currency": "currency", "customer_facing_code": "customer_facing_code", "discount_external_id": "discount_external_id", "duration": "duration", "duration_in_months": 1, "ended_at": "2024-01-15T09:30:00Z", "is_active": true, "percent_off": 1.1, "promo_code_external_id": "promo_code_external_id", "started_at": "2024-01-15T09:30:00Z", "subscription_external_id": "subscription_external_id"}, map[string]interface{}{"amount_off": 1, "coupon_id": "coupon_id", "coupon_name": "coupon_name", "currency": "currency", "customer_facing_code": "customer_facing_code", "discount_external_id": "discount_external_id", "duration": "duration", "duration_in_months": 1, "ended_at": "2024-01-15T09:30:00Z", "is_active": true, "percent_off": 1.1, "promo_code_external_id": "promo_code_external_id", "started_at": "2024-01-15T09:30:00Z", "subscription_external_id": "subscription_external_id"}}, "expired_at": "2024-01-15T09:30:00Z", "id": "id", "interval": "interval", "latest_invoice": map[string]interface{}{"amount_due": 1, "amount_paid": 1, "amount_remaining": 1, "collection_method": "collection_method", "company_id": "company_id", "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "customer_external_id": "customer_external_id", "due_date": "2024-01-15T09:30:00Z", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "payment_method_external_id": "payment_method_external_id", "subscription_external_id": "subscription_external_id", "subtotal": 1, "updated_at": "2024-01-15T09:30:00Z", "url": "url"}, "metadata": map[string]interface{}{"metadata": map[string]interface{}{"key": "value"}}, "payment_method": map[string]interface{}{"account_last4": "account_last4", "account_name": "account_name", "bank_name": "bank_name", "billing_email": "billing_email", "billing_name": "billing_name", "card_brand": "card_brand", "card_exp_month": 1, "card_exp_year": 1, "card_last4": "card_last4", "company_id": "company_id", "created_at": "2024-01-15T09:30:00Z", "customer_external_id": "customer_external_id", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "payment_method_type": "payment_method_type", "updated_at": "2024-01-15T09:30:00Z"}, "period_end": 1, "period_start": 1, "products": []interface{}{map[string]interface{}{"billing_scheme": "billing_scheme", "billing_threshold": 1, "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "interval": "interval", "meter_id": "meter_id", "name": "name", "package_size": 1, "price": 1, "price_decimal": "price_decimal", "price_external_id": "price_external_id", "price_id": "price_id", "price_tier": []interface{}{map[string]interface{}{"flat_amount": 1, "per_unit_price": 1, "per_unit_price_decimal": "per_unit_price_decimal", "up_to": 1}, map[string]interface{}{"flat_amount": 1, "per_unit_price": 1, "per_unit_price_decimal": "per_unit_price_decimal", "up_to": 1}}, "quantity": 1.1, "subscription_id": "subscription_id", "subscription_item_external_id": "subscription_item_external_id", "updated_at": "2024-01-15T09:30:00Z", "usage_type": "usage_type"}, map[string]interface{}{"billing_scheme": "billing_scheme", "billing_threshold": 1, "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "interval": "interval", "meter_id": "meter_id", "name": "name", "package_size": 1, "price": 1, "price_decimal": "price_decimal", "price_external_id": "price_external_id", "price_id": "price_id", "price_tier": []interface{}{map[string]interface{}{"flat_amount": 1, "per_unit_price": 1, "per_unit_price_decimal": "per_unit_price_decimal", "up_to": 1}, map[string]interface{}{"flat_amount": 1, "per_unit_price": 1, "per_unit_price_decimal": "per_unit_price_decimal", "up_to": 1}}, "quantity": 1.1, "subscription_id": "subscription_id", "subscription_item_external_id": "subscription_item_external_id", "updated_at": "2024-01-15T09:30:00Z", "usage_type": "usage_type"}}, "status": "status", "subscription_external_id": "subscription_external_id", "total_price": 1, "trial_end": 1, "trial_end_setting": "trial_end_setting"}, "billing_subscriptions": []interface{}{map[string]interface{}{"cancel_at": 1, "cancel_at_period_end": true, "company_id": "company_id", "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "customer_external_id": "customer_external_id", "default_payment_method_id": "default_payment_method_id", "discounts": []interface{}{map[string]interface{}{"amount_off": 1, "coupon_id": "coupon_id", "coupon_name": "coupon_name", "currency": "currency", "customer_facing_code": "customer_facing_code", "discount_external_id": "discount_external_id", "duration": "duration", "duration_in_months": 1, "ended_at": "2024-01-15T09:30:00Z", "is_active": true, "percent_off": 1.1, "promo_code_external_id": "promo_code_external_id", "started_at": "2024-01-15T09:30:00Z", "subscription_external_id": "subscription_external_id"}, map[string]interface{}{"amount_off": 1, "coupon_id": "coupon_id", "coupon_name": "coupon_name", "currency": "currency", "customer_facing_code": "customer_facing_code", "discount_external_id": "discount_external_id", "duration": "duration", "duration_in_months": 1, "ended_at": "2024-01-15T09:30:00Z", "is_active": true, "percent_off": 1.1, "promo_code_external_id": "promo_code_external_id", "started_at": "2024-01-15T09:30:00Z", "subscription_external_id": "subscription_external_id"}}, "expired_at": "2024-01-15T09:30:00Z", "id": "id", "interval": "interval", "latest_invoice": map[string]interface{}{"amount_due": 1, "amount_paid": 1, "amount_remaining": 1, "collection_method": "collection_method", "company_id": "company_id", "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "customer_external_id": "customer_external_id", "due_date": "2024-01-15T09:30:00Z", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "payment_method_external_id": "payment_method_external_id", "subscription_external_id": "subscription_external_id", "subtotal": 1, "updated_at": "2024-01-15T09:30:00Z", "url": "url"}, "metadata": map[string]interface{}{"metadata": map[string]interface{}{"key": "value"}}, "payment_method": map[string]interface{}{"account_last4": "account_last4", "account_name": "account_name", "bank_name": "bank_name", "billing_email": "billing_email", "billing_name": "billing_name", "card_brand": "card_brand", "card_exp_month": 1, "card_exp_year": 1, "card_last4": "card_last4", "company_id": "company_id", "created_at": "2024-01-15T09:30:00Z", "customer_external_id": "customer_external_id", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "payment_method_type": "payment_method_type", "updated_at": "2024-01-15T09:30:00Z"}, "period_end": 1, "period_start": 1, "products": []interface{}{map[string]interface{}{"billing_scheme": "billing_scheme", "billing_threshold": 1, "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "interval": "interval", "meter_id": "meter_id", "name": "name", "package_size": 1, "price": 1, "price_decimal": "price_decimal", "price_external_id": "price_external_id", "price_id": "price_id", "price_tier": []interface{}{map[string]interface{}{"flat_amount": 1, "per_unit_price": 1, "per_unit_price_decimal": "per_unit_price_decimal", "up_to": 1}, map[string]interface{}{"flat_amount": 1, "per_unit_price": 1, "per_unit_price_decimal": "per_unit_price_decimal", "up_to": 1}}, "quantity": 1.1, "subscription_id": "subscription_id", "subscription_item_external_id": "subscription_item_external_id", "updated_at": "2024-01-15T09:30:00Z", "usage_type": "usage_type"}, map[string]interface{}{"billing_scheme": "billing_scheme", "billing_threshold": 1, "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "interval": "interval", "meter_id": "meter_id", "name": "name", "package_size": 1, "price": 1, "price_decimal": "price_decimal", "price_external_id": "price_external_id", "price_id": "price_id", "price_tier": []interface{}{map[string]interface{}{"flat_amount": 1, "per_unit_price": 1, "per_unit_price_decimal": "per_unit_price_decimal", "up_to": 1}, map[string]interface{}{"flat_amount": 1, "per_unit_price": 1, "per_unit_price_decimal": "per_unit_price_decimal", "up_to": 1}}, "quantity": 1.1, "subscription_id": "subscription_id", "subscription_item_external_id": "subscription_item_external_id", "updated_at": "2024-01-15T09:30:00Z", "usage_type": "usage_type"}}, "status": "status", "subscription_external_id": "subscription_external_id", "total_price": 1, "trial_end": 1, "trial_end_setting": "trial_end_setting"}, map[string]interface{}{"cancel_at": 1, "cancel_at_period_end": true, "company_id": "company_id", "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "customer_external_id": "customer_external_id", "default_payment_method_id": "default_payment_method_id", "discounts": []interface{}{map[string]interface{}{"amount_off": 1, "coupon_id": "coupon_id", "coupon_name": "coupon_name", "currency": "currency", "customer_facing_code": "customer_facing_code", "discount_external_id": "discount_external_id", "duration": "duration", "duration_in_months": 1, "ended_at": "2024-01-15T09:30:00Z", "is_active": true, "percent_off": 1.1, "promo_code_external_id": "promo_code_external_id", "started_at": "2024-01-15T09:30:00Z", "subscription_external_id": "subscription_external_id"}, map[string]interface{}{"amount_off": 1, "coupon_id": "coupon_id", "coupon_name": "coupon_name", "currency": "currency", "customer_facing_code": "customer_facing_code", "discount_external_id": "discount_external_id", "duration": "duration", "duration_in_months": 1, "ended_at": "2024-01-15T09:30:00Z", "is_active": true, "percent_off": 1.1, "promo_code_external_id": "promo_code_external_id", "started_at": "2024-01-15T09:30:00Z", "subscription_external_id": "subscription_external_id"}}, "expired_at": "2024-01-15T09:30:00Z", "id": "id", "interval": "interval", "latest_invoice": map[string]interface{}{"amount_due": 1, "amount_paid": 1, "amount_remaining": 1, "collection_method": "collection_method", "company_id": "company_id", "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "customer_external_id": "customer_external_id", "due_date": "2024-01-15T09:30:00Z", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "payment_method_external_id": "payment_method_external_id", "subscription_external_id": "subscription_external_id", "subtotal": 1, "updated_at": "2024-01-15T09:30:00Z", "url": "url"}, "metadata": map[string]interface{}{"metadata": map[string]interface{}{"key": "value"}}, "payment_method": map[string]interface{}{"account_last4": "account_last4", "account_name": "account_name", "bank_name": "bank_name", "billing_email": "billing_email", "billing_name": "billing_name", "card_brand": "card_brand", "card_exp_month": 1, "card_exp_year": 1, "card_last4": "card_last4", "company_id": "company_id", "created_at": "2024-01-15T09:30:00Z", "customer_external_id": "customer_external_id", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "payment_method_type": "payment_method_type", "updated_at": "2024-01-15T09:30:00Z"}, "period_end": 1, "period_start": 1, "products": []interface{}{map[string]interface{}{"billing_scheme": "billing_scheme", "billing_threshold": 1, "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "interval": "interval", "meter_id": "meter_id", "name": "name", "package_size": 1, "price": 1, "price_decimal": "price_decimal", "price_external_id": "price_external_id", "price_id": "price_id", "price_tier": []interface{}{map[string]interface{}{"flat_amount": 1, "per_unit_price": 1, "per_unit_price_decimal": "per_unit_price_decimal", "up_to": 1}, map[string]interface{}{"flat_amount": 1, "per_unit_price": 1, "per_unit_price_decimal": "per_unit_price_decimal", "up_to": 1}}, "quantity": 1.1, "subscription_id": "subscription_id", "subscription_item_external_id": "subscription_item_external_id", "updated_at": "2024-01-15T09:30:00Z", "usage_type": "usage_type"}, map[string]interface{}{"billing_scheme": "billing_scheme", "billing_threshold": 1, "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "interval": "interval", "meter_id": "meter_id", "name": "name", "package_size": 1, "price": 1, "price_decimal": "price_decimal", "price_external_id": "price_external_id", "price_id": "price_id", "price_tier": []interface{}{map[string]interface{}{"flat_amount": 1, "per_unit_price": 1, "per_unit_price_decimal": "per_unit_price_decimal", "up_to": 1}, map[string]interface{}{"flat_amount": 1, "per_unit_price": 1, "per_unit_price_decimal": "per_unit_price_decimal", "up_to": 1}}, "quantity": 1.1, "subscription_id": "subscription_id", "subscription_item_external_id": "subscription_item_external_id", "updated_at": "2024-01-15T09:30:00Z", "usage_type": "usage_type"}}, "status": "status", "subscription_external_id": "subscription_external_id", "total_price": 1, "trial_end": 1, "trial_end_setting": "trial_end_setting"}}, "created_at": "2024-01-15T09:30:00Z", "default_payment_method": map[string]interface{}{"account_last4": "account_last4", "account_name": "account_name", "bank_name": "bank_name", "billing_email": "billing_email", "billing_name": "billing_name", "card_brand": "card_brand", "card_exp_month": 1, "card_exp_year": 1, "card_last4": "card_last4", "company_id": "company_id", "created_at": "2024-01-15T09:30:00Z", "customer_external_id": "customer_external_id", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "payment_method_type": "payment_method_type", "updated_at": "2024-01-15T09:30:00Z"}, "entity_traits": []interface{}{map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "definition": map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "display_name": "display_name", "entity_type": "entity_type", "hierarchy": []interface{}{"hierarchy", "hierarchy"}, "id": "id", "trait_type": "trait_type", "updated_at": "2024-01-15T09:30:00Z"}, "definition_id": "definition_id", "environment_id": "environment_id", "id": "id", "updated_at": "2024-01-15T09:30:00Z", "value": "value"}, map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "definition": map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "display_name": "display_name", "entity_type": "entity_type", "hierarchy": []interface{}{"hierarchy", "hierarchy"}, "id": "id", "trait_type": "trait_type", "updated_at": "2024-01-15T09:30:00Z"}, "definition_id": "definition_id", "environment_id": "environment_id", "id": "id", "updated_at": "2024-01-15T09:30:00Z", "value": "value"}}, "environment_id": "environment_id", "id": "id", "keys": []interface{}{map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "definition": map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "entity_type": "entity_type", "id": "id", "key": "key", "updated_at": "2024-01-15T09:30:00Z"}, "definition_id": "definition_id", "entity_id": "entity_id", "entity_type": "entity_type", "environment_id": "environment_id", "id": "id", "key": "key", "updated_at": "2024-01-15T09:30:00Z", "value": "value"}, map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "definition": map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "entity_type": "entity_type", "id": "id", "key": "key", "updated_at": "2024-01-15T09:30:00Z"}, "definition_id": "definition_id", "entity_id": "entity_id", "entity_type": "entity_type", "environment_id": "environment_id", "id": "id", "key": "key", "updated_at": "2024-01-15T09:30:00Z", "value": "value"}}, "last_seen_at": "2024-01-15T09:30:00Z", "logo_url": "logo_url", "metrics": []interface{}{map[string]interface{}{"account_id": "account_id", "captured_at_max": "2024-01-15T09:30:00Z", "captured_at_min": "2024-01-15T09:30:00Z", "company_id": "company_id", "created_at": "2024-01-15T09:30:00Z", "environment_id": "environment_id", "event_subtype": "event_subtype", "month_reset": "month_reset", "period": "period", "valid_until": "2024-01-15T09:30:00Z", "value": 1}, map[string]interface{}{"account_id": "account_id", "captured_at_max": "2024-01-15T09:30:00Z", "captured_at_min": "2024-01-15T09:30:00Z", "company_id": "company_id", "created_at": "2024-01-15T09:30:00Z", "environment_id": "environment_id", "event_subtype": "event_subtype", "month_reset": "month_reset", "period": "period", "valid_until": "2024-01-15T09:30:00Z", "value": 1}}, "name": "name", "payment_methods": []interface{}{map[string]interface{}{"account_last4": "account_last4", "account_name": "account_name", "bank_name": "bank_name", "billing_email": "billing_email", "billing_name": "billing_name", "card_brand": "card_brand", "card_exp_month": 1, "card_exp_year": 1, "card_last4": "card_last4", "company_id": "company_id", "created_at": "2024-01-15T09:30:00Z", "customer_external_id": "customer_external_id", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "payment_method_type": "payment_method_type", "updated_at": "2024-01-15T09:30:00Z"}, map[string]interface{}{"account_last4": "account_last4", "account_name": "account_name", "bank_name": "bank_name", "billing_email": "billing_email", "billing_name": "billing_name", "card_brand": "card_brand", "card_exp_month": 1, "card_exp_year": 1, "card_last4": "card_last4", "company_id": "company_id", "created_at": "2024-01-15T09:30:00Z", "customer_external_id": "customer_external_id", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "payment_method_type": "payment_method_type", "updated_at": "2024-01-15T09:30:00Z"}}, "plan": map[string]interface{}{"added_on": "2024-01-15T09:30:00Z", "billing_product_external_id": "billing_product_external_id", "billing_product_id": "billing_product_id", "description": "description", "id": "id", "image_url": "image_url", "name": "name", "plan_period": "plan_period", "plan_price": 1}, "plans": []interface{}{map[string]interface{}{"description": "description", "id": "id", "image_url": "image_url", "name": "name"}, map[string]interface{}{"description": "description", "id": "id", "image_url": "image_url", "name": "name"}}, "rules": []interface{}{map[string]interface{}{"account_id": "account_id", "condition_groups": []interface{}{map[string]interface{}{"conditions": []interface{}{map[string]interface{}{"account_id": "account_id", "comparison_trait_definition": map[string]interface{}{"comparable_type": "bool", "entity_type": "user", "id": "id"}, "condition_type": "base_plan", "consumption_rate": 1.1, "credit_id": "credit_id", "environment_id": "environment_id", "event_subtype": "event_subtype", "id": "id", "metric_period": "all_time", "metric_period_month_reset": "first_of_month", "metric_value": 1, "operator": "eq", "resource_ids": []interface{}{"resource_ids", "resource_ids"}, "trait_definition": map[string]interface{}{"comparable_type": "bool", "entity_type": "user", "id": "id"}, "trait_value": "trait_value"}, map[string]interface{}{"account_id": "account_id", "comparison_trait_definition": map[string]interface{}{"comparable_type": "bool", "entity_type": "user", "id": "id"}, "condition_type": "base_plan", "consumption_rate": 1.1, "credit_id": "credit_id", "environment_id": "environment_id", "event_subtype": "event_subtype", "id": "id", "metric_period": "all_time", "metric_period_month_reset": "first_of_month", "metric_value": 1, "operator": "eq", "resource_ids": []interface{}{"resource_ids", "resource_ids"}, "trait_definition": map[string]interface{}{"comparable_type": "bool", "entity_type": "user", "id": "id"}, "trait_value": "trait_value"}}}, map[string]interface{}{"conditions": []interface{}{map[string]interface{}{"account_id": "account_id", "comparison_trait_definition": map[string]interface{}{"comparable_type": "bool", "entity_type": "user", "id": "id"}, "condition_type": "base_plan", "consumption_rate": 1.1, "credit_id": "credit_id", "environment_id": "environment_id", "event_subtype": "event_subtype", "id": "id", "metric_period": "all_time", "metric_period_month_reset": "first_of_month", "metric_value": 1, "operator": "eq", "resource_ids": []interface{}{"resource_ids", "resource_ids"}, "trait_definition": map[string]interface{}{"comparable_type": "bool", "entity_type": "user", "id": "id"}, "trait_value": "trait_value"}, map[string]interface{}{"account_id": "account_id", "comparison_trait_definition": map[string]interface{}{"comparable_type": "bool", "entity_type": "user", "id": "id"}, "condition_type": "base_plan", "consumption_rate": 1.1, "credit_id": "credit_id", "environment_id": "environment_id", "event_subtype": "event_subtype", "id": "id", "metric_period": "all_time", "metric_period_month_reset": "first_of_month", "metric_value": 1, "operator": "eq", "resource_ids": []interface{}{"resource_ids", "resource_ids"}, "trait_definition": map[string]interface{}{"comparable_type": "bool", "entity_type": "user", "id": "id"}, "trait_value": "trait_value"}}}}, "conditions": []interface{}{map[string]interface{}{"account_id": "account_id", "comparison_trait_definition": map[string]interface{}{"comparable_type": "bool", "entity_type": "user", "id": "id"}, "condition_type": "base_plan", "consumption_rate": 1.1, "credit_id": "credit_id", "environment_id": "environment_id", "event_subtype": "event_subtype", "id": "id", "metric_period": "all_time", "metric_period_month_reset": "first_of_month", "metric_value": 1, "operator": "eq", "resource_ids": []interface{}{"resource_ids", "resource_ids"}, "trait_definition": map[string]interface{}{"comparable_type": "bool", "entity_type": "user", "id": "id"}, "trait_value": "trait_value"}, map[string]interface{}{"account_id": "account_id", "comparison_trait_definition": map[string]interface{}{"comparable_type": "bool", "entity_type": "user", "id": "id"}, "condition_type": "base_plan", "consumption_rate": 1.1, "credit_id": "credit_id", "environment_id": "environment_id", "event_subtype": "event_subtype", "id": "id", "metric_period": "all_time", "metric_period_month_reset": "first_of_month", "metric_value": 1, "operator": "eq", "resource_ids": []interface{}{"resource_ids", "resource_ids"}, "trait_definition": map[string]interface{}{"comparable_type": "bool", "entity_type": "user", "id": "id"}, "trait_value": "trait_value"}}, "environment_id": "environment_id", "flag_id": "flag_id", "id": "id", "name": "name", "priority": 1, "rule_type": "default", "value": true}, map[string]interface{}{"account_id": "account_id", "condition_groups": []interface{}{map[string]interface{}{"conditions": []interface{}{map[string]interface{}{"account_id": "account_id", "comparison_trait_definition": map[string]interface{}{"comparable_type": "bool", "entity_type": "user", "id": "id"}, "condition_type": "base_plan", "consumption_rate": 1.1, "credit_id": "credit_id", "environment_id": "environment_id", "event_subtype": "event_subtype", "id": "id", "metric_period": "all_time", "metric_period_month_reset": "first_of_month", "metric_value": 1, "operator": "eq", "resource_ids": []interface{}{"resource_ids", "resource_ids"}, "trait_definition": map[string]interface{}{"comparable_type": "bool", "entity_type": "user", "id": "id"}, "trait_value": "trait_value"}, map[string]interface{}{"account_id": "account_id", "comparison_trait_definition": map[string]interface{}{"comparable_type": "bool", "entity_type": "user", "id": "id"}, "condition_type": "base_plan", "consumption_rate": 1.1, "credit_id": "credit_id", "environment_id": "environment_id", "event_subtype": "event_subtype", "id": "id", "metric_period": "all_time", "metric_period_month_reset": "first_of_month", "metric_value": 1, "operator": "eq", "resource_ids": []interface{}{"resource_ids", "resource_ids"}, "trait_definition": map[string]interface{}{"comparable_type": "bool", "entity_type": "user", "id": "id"}, "trait_value": "trait_value"}}}, map[string]interface{}{"conditions": []interface{}{map[string]interface{}{"account_id": "account_id", "comparison_trait_definition": map[string]interface{}{"comparable_type": "bool", "entity_type": "user", "id": "id"}, "condition_type": "base_plan", "consumption_rate": 1.1, "credit_id": "credit_id", "environment_id": "environment_id", "event_subtype": "event_subtype", "id": "id", "metric_period": "all_time", "metric_period_month_reset": "first_of_month", "metric_value": 1, "operator": "eq", "resource_ids": []interface{}{"resource_ids", "resource_ids"}, "trait_definition": map[string]interface{}{"comparable_type": "bool", "entity_type": "user", "id": "id"}, "trait_value": "trait_value"}, map[string]interface{}{"account_id": "account_id", "comparison_trait_definition": map[string]interface{}{"comparable_type": "bool", "entity_type": "user", "id": "id"}, "condition_type": "base_plan", "consumption_rate": 1.1, "credit_id": "credit_id", "environment_id": "environment_id", "event_subtype": "event_subtype", "id": "id", "metric_period": "all_time", "metric_period_month_reset": "first_of_month", "metric_value": 1, "operator": "eq", "resource_ids": []interface{}{"resource_ids", "resource_ids"}, "trait_definition": map[string]interface{}{"comparable_type": "bool", "entity_type": "user", "id": "id"}, "trait_value": "trait_value"}}}}, "conditions": []interface{}{map[string]interface{}{"account_id": "account_id", "comparison_trait_definition": map[string]interface{}{"comparable_type": "bool", "entity_type": "user", "id": "id"}, "condition_type": "base_plan", "consumption_rate": 1.1, "credit_id": "credit_id", "environment_id": "environment_id", "event_subtype": "event_subtype", "id": "id", "metric_period": "all_time", "metric_period_month_reset": "first_of_month", "metric_value": 1, "operator": "eq", "resource_ids": []interface{}{"resource_ids", "resource_ids"}, "trait_definition": map[string]interface{}{"comparable_type": "bool", "entity_type": "user", "id": "id"}, "trait_value": "trait_value"}, map[string]interface{}{"account_id": "account_id", "comparison_trait_definition": map[string]interface{}{"comparable_type": "bool", "entity_type": "user", "id": "id"}, "condition_type": "base_plan", "consumption_rate": 1.1, "credit_id": "credit_id", "environment_id": "environment_id", "event_subtype": "event_subtype", "id": "id", "metric_period": "all_time", "metric_period_month_reset": "first_of_month", "metric_value": 1, "operator": "eq", "resource_ids": []interface{}{"resource_ids", "resource_ids"}, "trait_definition": map[string]interface{}{"comparable_type": "bool", "entity_type": "user", "id": "id"}, "trait_value": "trait_value"}}, "environment_id": "environment_id", "flag_id": "flag_id", "id": "id", "name": "name", "priority": 1, "rule_type": "default", "value": true}}, "traits": map[string]interface{}{"traits": map[string]interface{}{"key": "value"}}, "updated_at": "2024-01-15T09:30:00Z", "user_count": 1}, "params": map[string]interface{}{"keys": map[string]interface{}{"keys": "keys"}}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.LookupCompanyRequest{
		Keys: map[string]string{
			"keys": "keys",
		},
	}
	_, invocationErr := client.Companies.LookupCompany(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestCompaniesGetActiveDealsWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Get(gowiremock.URLPathTemplate("/company-crm-deals")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": []interface{}{map[string]interface{}{"deal_arr": "deal_arr", "deal_external_id": "deal_external_id", "deal_mrr": "deal_mrr", "deal_name": "deal_name", "line_items": []interface{}{map[string]interface{}{"billing_frequency": "billing_frequency", "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "description": "description", "id": "id", "name": "name", "price": 1.1, "quantity": 1, "updated_at": "2024-01-15T09:30:00Z"}}}}, "params": map[string]interface{}{"company_id": "company_id", "deal_stage": "deal_stage", "limit": 1, "offset": 1}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.GetActiveDealsRequest{
		CompanyID: "company_id",
		DealStage: "deal_stage",
		Limit: schematichq.Int(
			1,
		),
		Offset: schematichq.Int(
			1,
		),
	}
	_, invocationErr := client.Companies.GetActiveDeals(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestCompaniesListCompanyMembershipsWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Get(gowiremock.URLPathTemplate("/company-memberships")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": []interface{}{map[string]interface{}{"company": map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "environment_id": "environment_id", "id": "id", "name": "name", "updated_at": "2024-01-15T09:30:00Z"}, "company_id": "company_id", "created_at": "2024-01-15T09:30:00Z", "id": "id", "updated_at": "2024-01-15T09:30:00Z", "user_id": "user_id"}}, "params": map[string]interface{}{"company_id": "company_id", "limit": 1, "offset": 1, "user_id": "user_id"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.ListCompanyMembershipsRequest{
		CompanyID: schematichq.String(
			"company_id",
		),
		UserID: schematichq.String(
			"user_id",
		),
		Limit: schematichq.Int(
			1,
		),
		Offset: schematichq.Int(
			1,
		),
	}
	_, invocationErr := client.Companies.ListCompanyMemberships(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestCompaniesGetOrCreateCompanyMembershipWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Post(gowiremock.URLPathTemplate("/company-memberships")).WithBodyPattern(gowiremock.MatchesJsonSchema(`{
                    "$schema": "https://json-schema.org/draft/2020-12/schema",
                    "type": "object",
                    "required": ["company_id", "user_id"],
                    "properties": {
                        "company_id": {"type": "string"}, "user_id": {"type": "string"}
                    },
                    "additionalProperties": true
                }`, "V202012")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": map[string]interface{}{"company": map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "environment_id": "environment_id", "id": "id", "last_seen_at": "2024-01-15T09:30:00Z", "logo_url": "logo_url", "name": "name", "updated_at": "2024-01-15T09:30:00Z"}, "company_id": "company_id", "created_at": "2024-01-15T09:30:00Z", "id": "id", "updated_at": "2024-01-15T09:30:00Z", "user_id": "user_id"}, "params": map[string]interface{}{"key": "value"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.GetOrCreateCompanyMembershipRequestBody{
		CompanyID: "company_id",
		UserID:    "user_id",
	}
	_, invocationErr := client.Companies.GetOrCreateCompanyMembership(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestCompaniesDeleteCompanyMembershipWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Delete(gowiremock.URLPathTemplate("/company-memberships/{company_membership_id}")).WithPathParam(
		"company_membership_id",
		gowiremock.Matching("company_membership_id"),
	).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": map[string]interface{}{"deleted": true}, "params": map[string]interface{}{"key": "value"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	_, invocationErr := client.Companies.DeleteCompanyMembership(
		context.TODO(),
		"company_membership_id",
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestCompaniesGetActiveCompanySubscriptionWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Get(gowiremock.URLPathTemplate("/company-subscriptions")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": []interface{}{map[string]interface{}{"cancel_at": "2024-01-15T09:30:00Z", "cancel_at_period_end": true, "currency": "currency", "customer_external_id": "customer_external_id", "discounts": []interface{}{map[string]interface{}{"coupon_id": "coupon_id", "coupon_name": "coupon_name", "discount_external_id": "discount_external_id", "duration": "duration", "is_active": true, "started_at": "2024-01-15T09:30:00Z", "subscription_external_id": "subscription_external_id"}}, "expired_at": "2024-01-15T09:30:00Z", "interval": "interval", "latest_invoice": map[string]interface{}{"amount_due": 1, "amount_paid": 1, "amount_remaining": 1, "collection_method": "collection_method", "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "customer_external_id": "customer_external_id", "environment_id": "environment_id", "id": "id", "subtotal": 1, "updated_at": "2024-01-15T09:30:00Z"}, "payment_method": map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "customer_external_id": "customer_external_id", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "payment_method_type": "payment_method_type", "updated_at": "2024-01-15T09:30:00Z"}, "products": []interface{}{map[string]interface{}{"billing_scheme": "billing_scheme", "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "interval": "interval", "name": "name", "package_size": 1, "price": 1, "price_external_id": "price_external_id", "price_id": "price_id", "price_tier": []interface{}{map[string]interface{}{}}, "quantity": 1.1, "subscription_id": "subscription_id", "updated_at": "2024-01-15T09:30:00Z", "usage_type": "usage_type"}}, "status": "status", "subscription_external_id": "subscription_external_id", "total_price": 1, "trial_end": "2024-01-15T09:30:00Z"}}, "params": map[string]interface{}{"company_id": "company_id", "company_ids": []interface{}{"company_ids"}, "limit": 1, "offset": 1}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.GetActiveCompanySubscriptionRequest{
		CompanyID: schematichq.String(
			"company_id",
		),
		Limit: schematichq.Int(
			1,
		),
		Offset: schematichq.Int(
			1,
		),
	}
	_, invocationErr := client.Companies.GetActiveCompanySubscription(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestCompaniesUpsertCompanyTraitWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Post(gowiremock.URLPathTemplate("/company-traits")).WithBodyPattern(gowiremock.MatchesJsonSchema("{}", "V202012")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": map[string]interface{}{"add_ons": []interface{}{map[string]interface{}{"id": "id", "name": "name"}}, "billing_credit_balances": map[string]interface{}{"key": 1.1}, "billing_subscription": map[string]interface{}{"cancel_at": 1, "cancel_at_period_end": true, "company_id": "company_id", "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "customer_external_id": "customer_external_id", "default_payment_method_id": "default_payment_method_id", "discounts": []interface{}{map[string]interface{}{"coupon_id": "coupon_id", "coupon_name": "coupon_name", "discount_external_id": "discount_external_id", "duration": "duration", "is_active": true, "started_at": "2024-01-15T09:30:00Z", "subscription_external_id": "subscription_external_id"}}, "expired_at": "2024-01-15T09:30:00Z", "id": "id", "interval": "interval", "latest_invoice": map[string]interface{}{"amount_due": 1, "amount_paid": 1, "amount_remaining": 1, "collection_method": "collection_method", "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "customer_external_id": "customer_external_id", "environment_id": "environment_id", "id": "id", "subtotal": 1, "updated_at": "2024-01-15T09:30:00Z"}, "metadata": map[string]interface{}{"key": "value"}, "payment_method": map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "customer_external_id": "customer_external_id", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "payment_method_type": "payment_method_type", "updated_at": "2024-01-15T09:30:00Z"}, "period_end": 1, "period_start": 1, "products": []interface{}{map[string]interface{}{"billing_scheme": "billing_scheme", "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "interval": "interval", "name": "name", "package_size": 1, "price": 1, "price_external_id": "price_external_id", "price_id": "price_id", "price_tier": []interface{}{map[string]interface{}{}}, "quantity": 1.1, "subscription_id": "subscription_id", "updated_at": "2024-01-15T09:30:00Z", "usage_type": "usage_type"}}, "status": "status", "subscription_external_id": "subscription_external_id", "total_price": 1, "trial_end": 1, "trial_end_setting": "trial_end_setting"}, "billing_subscriptions": []interface{}{map[string]interface{}{"cancel_at_period_end": true, "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "customer_external_id": "customer_external_id", "discounts": []interface{}{map[string]interface{}{"coupon_id": "coupon_id", "coupon_name": "coupon_name", "discount_external_id": "discount_external_id", "duration": "duration", "is_active": true, "started_at": "2024-01-15T09:30:00Z", "subscription_external_id": "subscription_external_id"}}, "id": "id", "interval": "interval", "period_end": 1, "period_start": 1, "products": []interface{}{map[string]interface{}{"billing_scheme": "billing_scheme", "created_at": "2024-01-15T09:30:00Z", "currency": "currency", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "interval": "interval", "name": "name", "package_size": 1, "price": 1, "price_external_id": "price_external_id", "price_id": "price_id", "price_tier": []interface{}{map[string]interface{}{}}, "quantity": 1.1, "subscription_id": "subscription_id", "updated_at": "2024-01-15T09:30:00Z", "usage_type": "usage_type"}}, "status": "status", "subscription_external_id": "subscription_external_id", "total_price": 1}}, "created_at": "2024-01-15T09:30:00Z", "default_payment_method": map[string]interface{}{"account_last4": "account_last4", "account_name": "account_name", "bank_name": "bank_name", "billing_email": "billing_email", "billing_name": "billing_name", "card_brand": "card_brand", "card_exp_month": 1, "card_exp_year": 1, "card_last4": "card_last4", "company_id": "company_id", "created_at": "2024-01-15T09:30:00Z", "customer_external_id": "customer_external_id", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "payment_method_type": "payment_method_type", "updated_at": "2024-01-15T09:30:00Z"}, "entity_traits": []interface{}{map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "definition_id": "definition_id", "environment_id": "environment_id", "id": "id", "updated_at": "2024-01-15T09:30:00Z", "value": "value"}}, "environment_id": "environment_id", "id": "id", "keys": []interface{}{map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "definition_id": "definition_id", "entity_id": "entity_id", "entity_type": "entity_type", "environment_id": "environment_id", "id": "id", "key": "key", "updated_at": "2024-01-15T09:30:00Z", "value": "value"}}, "last_seen_at": "2024-01-15T09:30:00Z", "logo_url": "logo_url", "metrics": []interface{}{map[string]interface{}{"account_id": "account_id", "captured_at_max": "2024-01-15T09:30:00Z", "captured_at_min": "2024-01-15T09:30:00Z", "company_id": "company_id", "created_at": "2024-01-15T09:30:00Z", "environment_id": "environment_id", "event_subtype": "event_subtype", "month_reset": "month_reset", "period": "period", "value": 1}}, "name": "name", "payment_methods": []interface{}{map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "customer_external_id": "customer_external_id", "environment_id": "environment_id", "external_id": "external_id", "id": "id", "payment_method_type": "payment_method_type", "updated_at": "2024-01-15T09:30:00Z"}}, "plan": map[string]interface{}{"added_on": "2024-01-15T09:30:00Z", "billing_product_external_id": "billing_product_external_id", "billing_product_id": "billing_product_id", "description": "description", "id": "id", "image_url": "image_url", "name": "name", "plan_period": "plan_period", "plan_price": 1}, "plans": []interface{}{map[string]interface{}{"id": "id", "name": "name"}}, "rules": []interface{}{map[string]interface{}{"account_id": "account_id", "condition_groups": []interface{}{map[string]interface{}{"conditions": []interface{}{map[string]interface{}{"account_id": "account_id", "condition_type": "base_plan", "environment_id": "environment_id", "id": "id", "operator": "eq", "resource_ids": []interface{}{"resource_ids"}, "trait_value": "trait_value"}}}}, "conditions": []interface{}{map[string]interface{}{"account_id": "account_id", "condition_type": "base_plan", "environment_id": "environment_id", "id": "id", "operator": "eq", "resource_ids": []interface{}{"resource_ids"}, "trait_value": "trait_value"}}, "environment_id": "environment_id", "id": "id", "name": "name", "priority": 1, "rule_type": "default", "value": true}}, "traits": map[string]interface{}{"key": "value"}, "updated_at": "2024-01-15T09:30:00Z", "user_count": 1}, "params": map[string]interface{}{"key": "value"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.UpsertTraitRequestBody{
		Keys: map[string]string{
			"key": "value",
		},
		Trait: "trait",
	}
	_, invocationErr := client.Companies.UpsertCompanyTrait(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestCompaniesListEntityKeyDefinitionsWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Get(gowiremock.URLPathTemplate("/entity-key-definitions")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": []interface{}{map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "entity_type": "entity_type", "id": "id", "key": "key", "updated_at": "2024-01-15T09:30:00Z"}}, "params": map[string]interface{}{"entity_type": "company", "ids": []interface{}{"ids"}, "limit": 1, "offset": 1, "q": "q"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.ListEntityKeyDefinitionsRequest{
		EntityType: schematichq.ListEntityKeyDefinitionsRequestEntityTypeCompany.Ptr(),
		Q: schematichq.String(
			"q",
		),
		Limit: schematichq.Int(
			1,
		),
		Offset: schematichq.Int(
			1,
		),
	}
	_, invocationErr := client.Companies.ListEntityKeyDefinitions(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestCompaniesCountEntityKeyDefinitionsWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Get(gowiremock.URLPathTemplate("/entity-key-definitions/count")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": map[string]interface{}{"count": 1}, "params": map[string]interface{}{"entity_type": "company", "ids": []interface{}{"ids"}, "limit": 1, "offset": 1, "q": "q"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.CountEntityKeyDefinitionsRequest{
		EntityType: schematichq.CountEntityKeyDefinitionsRequestEntityTypeCompany.Ptr(),
		Q: schematichq.String(
			"q",
		),
		Limit: schematichq.Int(
			1,
		),
		Offset: schematichq.Int(
			1,
		),
	}
	_, invocationErr := client.Companies.CountEntityKeyDefinitions(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestCompaniesListEntityTraitDefinitionsWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Get(gowiremock.URLPathTemplate("/entity-trait-definitions")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": []interface{}{map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "display_name": "display_name", "entity_type": "entity_type", "hierarchy": []interface{}{"hierarchy"}, "id": "id", "trait_type": "trait_type", "updated_at": "2024-01-15T09:30:00Z"}}, "params": map[string]interface{}{"entity_type": "company", "ids": []interface{}{"ids"}, "limit": 1, "offset": 1, "q": "q", "trait_type": "boolean"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.ListEntityTraitDefinitionsRequest{
		EntityType: schematichq.ListEntityTraitDefinitionsRequestEntityTypeCompany.Ptr(),
		Q: schematichq.String(
			"q",
		),
		TraitType: schematichq.ListEntityTraitDefinitionsRequestTraitTypeBoolean.Ptr(),
		Limit: schematichq.Int(
			1,
		),
		Offset: schematichq.Int(
			1,
		),
	}
	_, invocationErr := client.Companies.ListEntityTraitDefinitions(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestCompaniesGetOrCreateEntityTraitDefinitionWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Post(gowiremock.URLPathTemplate("/entity-trait-definitions")).WithBodyPattern(gowiremock.MatchesJsonSchema(`{
                    "$schema": "https://json-schema.org/draft/2020-12/schema",
                    "type": "object",
                    "required": ["entity_type", "hierarchy", "trait_type"],
                    "properties": {
                        "entity_type": {"type": "string"}, "hierarchy": {"type": "array", "items": {"type": "string"}}, "trait_type": {"type": "string"}
                    },
                    "additionalProperties": true
                }`, "V202012")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "display_name": "display_name", "entity_type": "entity_type", "hierarchy": []interface{}{"hierarchy"}, "id": "id", "trait_type": "trait_type", "updated_at": "2024-01-15T09:30:00Z"}, "params": map[string]interface{}{"key": "value"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.CreateEntityTraitDefinitionRequestBody{
		EntityType: schematichq.CreateEntityTraitDefinitionRequestBodyEntityTypeCompany,
		Hierarchy: []string{
			"hierarchy",
		},
		TraitType: schematichq.CreateEntityTraitDefinitionRequestBodyTraitTypeBoolean,
	}
	_, invocationErr := client.Companies.GetOrCreateEntityTraitDefinition(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestCompaniesGetEntityTraitDefinitionWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Get(gowiremock.URLPathTemplate("/entity-trait-definitions/{entity_trait_definition_id}")).WithPathParam(
		"entity_trait_definition_id",
		gowiremock.Matching("entity_trait_definition_id"),
	).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "display_name": "display_name", "entity_type": "entity_type", "hierarchy": []interface{}{"hierarchy"}, "id": "id", "trait_type": "trait_type", "updated_at": "2024-01-15T09:30:00Z"}, "params": map[string]interface{}{"key": "value"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	_, invocationErr := client.Companies.GetEntityTraitDefinition(
		context.TODO(),
		"entity_trait_definition_id",
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestCompaniesUpdateEntityTraitDefinitionWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Put(gowiremock.URLPathTemplate("/entity-trait-definitions/{entity_trait_definition_id}")).WithPathParam(
		"entity_trait_definition_id",
		gowiremock.Matching("entity_trait_definition_id"),
	).WithBodyPattern(gowiremock.MatchesJsonSchema(`{
                    "$schema": "https://json-schema.org/draft/2020-12/schema",
                    "type": "object",
                    "required": ["trait_type"],
                    "properties": {
                        "trait_type": {"type": "string"}
                    },
                    "additionalProperties": true
                }`, "V202012")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "display_name": "display_name", "entity_type": "entity_type", "hierarchy": []interface{}{"hierarchy"}, "id": "id", "trait_type": "trait_type", "updated_at": "2024-01-15T09:30:00Z"}, "params": map[string]interface{}{"key": "value"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.UpdateEntityTraitDefinitionRequestBody{
		TraitType: schematichq.UpdateEntityTraitDefinitionRequestBodyTraitTypeBoolean,
	}
	_, invocationErr := client.Companies.UpdateEntityTraitDefinition(
		context.TODO(),
		"entity_trait_definition_id",
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestCompaniesCountEntityTraitDefinitionsWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Get(gowiremock.URLPathTemplate("/entity-trait-definitions/count")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": map[string]interface{}{"count": 1}, "params": map[string]interface{}{"entity_type": "company", "ids": []interface{}{"ids"}, "limit": 1, "offset": 1, "q": "q", "trait_type": "boolean"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.CountEntityTraitDefinitionsRequest{
		EntityType: schematichq.CountEntityTraitDefinitionsRequestEntityTypeCompany.Ptr(),
		Q: schematichq.String(
			"q",
		),
		TraitType: schematichq.CountEntityTraitDefinitionsRequestTraitTypeBoolean.Ptr(),
		Limit: schematichq.Int(
			1,
		),
		Offset: schematichq.Int(
			1,
		),
	}
	_, invocationErr := client.Companies.CountEntityTraitDefinitions(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestCompaniesGetEntityTraitValuesWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Get(gowiremock.URLPathTemplate("/entity-trait-values")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": []interface{}{map[string]interface{}{"definition_id": "definition_id", "value": "value"}}, "params": map[string]interface{}{"definition_id": "definition_id", "limit": 1, "offset": 1, "q": "q"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.GetEntityTraitValuesRequest{
		DefinitionID: "definition_id",
		Q: schematichq.String(
			"q",
		),
		Limit: schematichq.Int(
			1,
		),
		Offset: schematichq.Int(
			1,
		),
	}
	_, invocationErr := client.Companies.GetEntityTraitValues(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestCompaniesListPlanChangesWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Get(gowiremock.URLPathTemplate("/plan-changes")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": []interface{}{map[string]interface{}{"action": "checkout", "actor_type": "app_user", "add_ons_added": []interface{}{map[string]interface{}{"deleted": true, "description": "description", "icon": "icon", "id": "id", "name": "name"}}, "add_ons_removed": []interface{}{map[string]interface{}{"deleted": true, "description": "description", "icon": "icon", "id": "id", "name": "name"}}, "api_key": map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "id": "id", "name": "name", "scopes": []interface{}{"scopes"}, "updated_at": "2024-01-15T09:30:00Z"}, "api_key_request": map[string]interface{}{"api_key_id": "api_key_id", "id": "id", "method": "method", "started_at": "2024-01-15T09:30:00Z", "url": "url"}, "base_plan": map[string]interface{}{"deleted": true, "description": "description", "icon": "icon", "id": "id", "name": "name"}, "base_plan_action": "fallback", "company": map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "environment_id": "environment_id", "id": "id", "name": "name", "updated_at": "2024-01-15T09:30:00Z"}, "company_id": "company_id", "created_at": "2024-01-15T09:30:00Z", "environment_id": "environment_id", "id": "id", "previous_base_plan": map[string]interface{}{"deleted": true, "description": "description", "icon": "icon", "id": "id", "name": "name"}, "request_id": "request_id", "subscription_change_action": "downgrade", "traits_updated": []interface{}{map[string]interface{}{"feature_id": "feature_id", "hierarchy": []interface{}{"hierarchy"}, "reason": "reason", "trait_id": "trait_id", "trait_name": "trait_name", "trait_type": "trait_type", "value": "value"}}, "updated_at": "2024-01-15T09:30:00Z", "user_id": "user_id", "user_name": "user_name"}}, "params": map[string]interface{}{"action": "action", "base_plan_action": "base_plan_action", "company_id": "company_id", "company_ids": []interface{}{"company_ids"}, "limit": 1, "offset": 1, "plan_ids": []interface{}{"plan_ids"}}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.ListPlanChangesRequest{
		Action: schematichq.String(
			"action",
		),
		BasePlanAction: schematichq.String(
			"base_plan_action",
		),
		CompanyID: schematichq.String(
			"company_id",
		),
		Limit: schematichq.Int(
			1,
		),
		Offset: schematichq.Int(
			1,
		),
	}
	_, invocationErr := client.Companies.ListPlanChanges(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestCompaniesGetPlanChangeWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Get(gowiremock.URLPathTemplate("/plan-changes/{plan_change_id}")).WithPathParam(
		"plan_change_id",
		gowiremock.Matching("plan_change_id"),
	).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": map[string]interface{}{"action": "checkout", "actor_type": "app_user", "add_ons_added": []interface{}{map[string]interface{}{"deleted": true, "description": "description", "icon": "icon", "id": "id", "name": "name"}}, "add_ons_removed": []interface{}{map[string]interface{}{"deleted": true, "description": "description", "icon": "icon", "id": "id", "name": "name"}}, "api_key": map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "description": "description", "environment_id": "environment_id", "id": "id", "last_used_at": "2024-01-15T09:30:00Z", "name": "name", "scopes": []interface{}{"scopes"}, "updated_at": "2024-01-15T09:30:00Z"}, "api_key_request": map[string]interface{}{"api_key_id": "api_key_id", "ended_at": "2024-01-15T09:30:00Z", "environment_id": "environment_id", "id": "id", "method": "method", "req_body": "req_body", "request_type": "request_type", "resource_id": 1, "resource_id_string": "resource_id_string", "resource_name": "resource_name", "resource_type": "resource_type", "resp_code": 1, "secondary_resource": "secondary_resource", "started_at": "2024-01-15T09:30:00Z", "url": "url", "user_name": "user_name"}, "base_plan": map[string]interface{}{"deleted": true, "description": "description", "icon": "icon", "id": "id", "name": "name"}, "base_plan_action": "fallback", "company": map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "environment_id": "environment_id", "id": "id", "last_seen_at": "2024-01-15T09:30:00Z", "logo_url": "logo_url", "name": "name", "updated_at": "2024-01-15T09:30:00Z"}, "company_id": "company_id", "created_at": "2024-01-15T09:30:00Z", "environment_id": "environment_id", "id": "id", "previous_base_plan": map[string]interface{}{"deleted": true, "description": "description", "icon": "icon", "id": "id", "name": "name"}, "request_id": "request_id", "subscription_change_action": "downgrade", "traits_updated": []interface{}{map[string]interface{}{"feature_id": "feature_id", "hierarchy": []interface{}{"hierarchy"}, "reason": "reason", "trait_id": "trait_id", "trait_name": "trait_name", "trait_type": "trait_type", "value": "value"}}, "updated_at": "2024-01-15T09:30:00Z", "user_id": "user_id", "user_name": "user_name"}, "params": map[string]interface{}{"key": "value"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	_, invocationErr := client.Companies.GetPlanChange(
		context.TODO(),
		"plan_change_id",
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestCompaniesListPlanTraitsWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Get(gowiremock.URLPathTemplate("/plan-traits")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": []interface{}{map[string]interface{}{"account_id": "account_id", "created_at": "2024-01-15T09:30:00Z", "environment_id": "environment_id", "id": "id", "plan_id": "plan_id", "plan_type": "plan_type", "trait_id": "trait_id", "trait_value": "trait_value", "updated_at": "2024-01-15T09:30:00Z"}}, "params": map[string]interface{}{"ids": []interface{}{"ids"}, "limit": 1, "offset": 1, "plan_id": "plan_id", "trait_id": "trait_id", "trait_ids": []interface{}{"trait_ids"}}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.ListPlanTraitsRequest{
		PlanID: schematichq.String(
			"plan_id",
		),
		TraitID: schematichq.String(
			"trait_id",
		),
		Limit: schematichq.Int(
			1,
		),
		Offset: schematichq.Int(
			1,
		),
	}
	_, invocationErr := client.Companies.ListPlanTraits(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestCompaniesCreatePlanTraitWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Post(gowiremock.URLPathTemplate("/plan-traits")).WithBodyPattern(gowiremock.MatchesJsonSchema(`{
                    "$schema": "https://json-schema.org/draft/2020-12/schema",
                    "type": "object",
                    "required": ["plan_id", "trait_id", "trait_value"],
                    "properties": {
                        "plan_id": {"type": "string"}, "trait_id": {"type": "string"}, "trait_value": {"type": "string"}
                    },
                    "additionalProperties": true
                }`, "V202012")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": map[string]interface{}{"account_id": "account_id", "created_at": "2024-01-15T09:30:00Z", "environment_id": "environment_id", "id": "id", "plan_id": "plan_id", "plan_type": "plan_type", "trait_id": "trait_id", "trait_value": "trait_value", "updated_at": "2024-01-15T09:30:00Z"}, "params": map[string]interface{}{"key": "value"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.CreatePlanTraitRequestBody{
		PlanID:     "plan_id",
		TraitID:    "trait_id",
		TraitValue: "trait_value",
	}
	_, invocationErr := client.Companies.CreatePlanTrait(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestCompaniesGetPlanTraitWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Get(gowiremock.URLPathTemplate("/plan-traits/{plan_trait_id}")).WithPathParam(
		"plan_trait_id",
		gowiremock.Matching("plan_trait_id"),
	).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": map[string]interface{}{"account_id": "account_id", "created_at": "2024-01-15T09:30:00Z", "environment_id": "environment_id", "id": "id", "plan_id": "plan_id", "plan_type": "plan_type", "trait_id": "trait_id", "trait_value": "trait_value", "updated_at": "2024-01-15T09:30:00Z"}, "params": map[string]interface{}{"key": "value"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	_, invocationErr := client.Companies.GetPlanTrait(
		context.TODO(),
		"plan_trait_id",
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestCompaniesUpdatePlanTraitWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Put(gowiremock.URLPathTemplate("/plan-traits/{plan_trait_id}")).WithPathParam(
		"plan_trait_id",
		gowiremock.Matching("plan_trait_id"),
	).WithBodyPattern(gowiremock.MatchesJsonSchema(`{
                    "$schema": "https://json-schema.org/draft/2020-12/schema",
                    "type": "object",
                    "required": ["plan_id", "trait_value"],
                    "properties": {
                        "plan_id": {"type": "string"}, "trait_value": {"type": "string"}
                    },
                    "additionalProperties": true
                }`, "V202012")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": map[string]interface{}{"account_id": "account_id", "created_at": "2024-01-15T09:30:00Z", "environment_id": "environment_id", "id": "id", "plan_id": "plan_id", "plan_type": "plan_type", "trait_id": "trait_id", "trait_value": "trait_value", "updated_at": "2024-01-15T09:30:00Z"}, "params": map[string]interface{}{"key": "value"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.UpdatePlanTraitRequestBody{
		PlanID:     "plan_id",
		TraitValue: "trait_value",
	}
	_, invocationErr := client.Companies.UpdatePlanTrait(
		context.TODO(),
		"plan_trait_id",
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestCompaniesDeletePlanTraitWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Delete(gowiremock.URLPathTemplate("/plan-traits/{plan_trait_id}")).WithPathParam(
		"plan_trait_id",
		gowiremock.Matching("plan_trait_id"),
	).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": map[string]interface{}{"deleted": true}, "params": map[string]interface{}{"key": "value"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	_, invocationErr := client.Companies.DeletePlanTrait(
		context.TODO(),
		"plan_trait_id",
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestCompaniesUpdatePlanTraitsBulkWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Post(gowiremock.URLPathTemplate("/plan-traits/bulk")).WithBodyPattern(gowiremock.MatchesJsonSchema(`{
                    "$schema": "https://json-schema.org/draft/2020-12/schema",
                    "type": "object",
                    "required": ["plan_id", "traits"],
                    "properties": {
                        "plan_id": {"type": "string"}, "traits": {"type": "array", "items": {"type": "object"}}
                    },
                    "additionalProperties": true
                }`, "V202012")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": []interface{}{map[string]interface{}{"account_id": "account_id", "created_at": "2024-01-15T09:30:00Z", "environment_id": "environment_id", "id": "id", "plan_id": "plan_id", "plan_type": "plan_type", "trait_id": "trait_id", "trait_value": "trait_value", "updated_at": "2024-01-15T09:30:00Z"}}, "params": map[string]interface{}{"key": "value"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.UpdatePlanTraitBulkRequestBody{
		PlanID: "plan_id",
		Traits: []*schematichq.UpdatePlanTraitTraitRequestBody{
			&schematichq.UpdatePlanTraitTraitRequestBody{
				TraitID:    "trait_id",
				TraitValue: "trait_value",
			},
		},
	}
	_, invocationErr := client.Companies.UpdatePlanTraitsBulk(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestCompaniesCountPlanTraitsWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Get(gowiremock.URLPathTemplate("/plan-traits/count")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": map[string]interface{}{"count": 1}, "params": map[string]interface{}{"ids": []interface{}{"ids"}, "limit": 1, "offset": 1, "plan_id": "plan_id", "trait_id": "trait_id", "trait_ids": []interface{}{"trait_ids"}}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.CountPlanTraitsRequest{
		PlanID: schematichq.String(
			"plan_id",
		),
		TraitID: schematichq.String(
			"trait_id",
		),
		Limit: schematichq.Int(
			1,
		),
		Offset: schematichq.Int(
			1,
		),
	}
	_, invocationErr := client.Companies.CountPlanTraits(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestCompaniesUpsertUserTraitWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Post(gowiremock.URLPathTemplate("/user-traits")).WithBodyPattern(gowiremock.MatchesJsonSchema("{}", "V202012")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": map[string]interface{}{"company_memberships": []interface{}{map[string]interface{}{"company_id": "company_id", "created_at": "2024-01-15T09:30:00Z", "id": "id", "updated_at": "2024-01-15T09:30:00Z", "user_id": "user_id"}}, "created_at": "2024-01-15T09:30:00Z", "entity_traits": []interface{}{map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "definition_id": "definition_id", "environment_id": "environment_id", "id": "id", "updated_at": "2024-01-15T09:30:00Z", "value": "value"}}, "environment_id": "environment_id", "id": "id", "keys": []interface{}{map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "definition_id": "definition_id", "entity_id": "entity_id", "entity_type": "entity_type", "environment_id": "environment_id", "id": "id", "key": "key", "updated_at": "2024-01-15T09:30:00Z", "value": "value"}}, "last_seen_at": "2024-01-15T09:30:00Z", "name": "name", "traits": map[string]interface{}{"key": "value"}, "updated_at": "2024-01-15T09:30:00Z"}, "params": map[string]interface{}{"key": "value"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.UpsertTraitRequestBody{
		Keys: map[string]string{
			"key": "value",
		},
		Trait: "trait",
	}
	_, invocationErr := client.Companies.UpsertUserTrait(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestCompaniesListUsersWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Get(gowiremock.URLPathTemplate("/users")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": []interface{}{map[string]interface{}{"company_memberships": []interface{}{map[string]interface{}{"company_id": "company_id", "created_at": "2024-01-15T09:30:00Z", "id": "id", "updated_at": "2024-01-15T09:30:00Z", "user_id": "user_id"}}, "created_at": "2024-01-15T09:30:00Z", "entity_traits": []interface{}{map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "definition_id": "definition_id", "environment_id": "environment_id", "id": "id", "updated_at": "2024-01-15T09:30:00Z", "value": "value"}}, "environment_id": "environment_id", "id": "id", "keys": []interface{}{map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "definition_id": "definition_id", "entity_id": "entity_id", "entity_type": "entity_type", "environment_id": "environment_id", "id": "id", "key": "key", "updated_at": "2024-01-15T09:30:00Z", "value": "value"}}, "last_seen_at": "2024-01-15T09:30:00Z", "name": "name", "traits": map[string]interface{}{"key": "value"}, "updated_at": "2024-01-15T09:30:00Z"}}, "params": map[string]interface{}{"company_id": "company_id", "ids": []interface{}{"ids"}, "limit": 1, "offset": 1, "plan_id": "plan_id", "q": "q"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.ListUsersRequest{
		CompanyID: schematichq.String(
			"company_id",
		),
		PlanID: schematichq.String(
			"plan_id",
		),
		Q: schematichq.String(
			"q",
		),
		Limit: schematichq.Int(
			1,
		),
		Offset: schematichq.Int(
			1,
		),
	}
	_, invocationErr := client.Companies.ListUsers(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestCompaniesUpsertUserWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Post(gowiremock.URLPathTemplate("/users")).WithBodyPattern(gowiremock.MatchesJsonSchema("{}", "V202012")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": map[string]interface{}{"company_memberships": []interface{}{map[string]interface{}{"company_id": "company_id", "created_at": "2024-01-15T09:30:00Z", "id": "id", "updated_at": "2024-01-15T09:30:00Z", "user_id": "user_id"}}, "created_at": "2024-01-15T09:30:00Z", "entity_traits": []interface{}{map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "definition_id": "definition_id", "environment_id": "environment_id", "id": "id", "updated_at": "2024-01-15T09:30:00Z", "value": "value"}}, "environment_id": "environment_id", "id": "id", "keys": []interface{}{map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "definition_id": "definition_id", "entity_id": "entity_id", "entity_type": "entity_type", "environment_id": "environment_id", "id": "id", "key": "key", "updated_at": "2024-01-15T09:30:00Z", "value": "value"}}, "last_seen_at": "2024-01-15T09:30:00Z", "name": "name", "traits": map[string]interface{}{"key": "value"}, "updated_at": "2024-01-15T09:30:00Z"}, "params": map[string]interface{}{"key": "value"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.UpsertUserRequestBody{
		Keys: map[string]string{
			"key": "value",
		},
	}
	_, invocationErr := client.Companies.UpsertUser(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestCompaniesGetUserWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Get(gowiremock.URLPathTemplate("/users/{user_id}")).WithPathParam(
		"user_id",
		gowiremock.Matching("user_id"),
	).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": map[string]interface{}{"company_memberships": []interface{}{map[string]interface{}{"company_id": "company_id", "created_at": "2024-01-15T09:30:00Z", "id": "id", "updated_at": "2024-01-15T09:30:00Z", "user_id": "user_id"}}, "created_at": "2024-01-15T09:30:00Z", "entity_traits": []interface{}{map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "definition_id": "definition_id", "environment_id": "environment_id", "id": "id", "updated_at": "2024-01-15T09:30:00Z", "value": "value"}}, "environment_id": "environment_id", "id": "id", "keys": []interface{}{map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "definition_id": "definition_id", "entity_id": "entity_id", "entity_type": "entity_type", "environment_id": "environment_id", "id": "id", "key": "key", "updated_at": "2024-01-15T09:30:00Z", "value": "value"}}, "last_seen_at": "2024-01-15T09:30:00Z", "name": "name", "traits": map[string]interface{}{"key": "value"}, "updated_at": "2024-01-15T09:30:00Z"}, "params": map[string]interface{}{"key": "value"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	_, invocationErr := client.Companies.GetUser(
		context.TODO(),
		"user_id",
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestCompaniesDeleteUserWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Delete(gowiremock.URLPathTemplate("/users/{user_id}")).WithPathParam(
		"user_id",
		gowiremock.Matching("user_id"),
	).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": map[string]interface{}{"deleted": true}, "params": map[string]interface{}{"key": "value"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	_, invocationErr := client.Companies.DeleteUser(
		context.TODO(),
		"user_id",
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestCompaniesCountUsersWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Get(gowiremock.URLPathTemplate("/users/count")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": map[string]interface{}{"count": 1}, "params": map[string]interface{}{"company_id": "company_id", "ids": []interface{}{"ids"}, "limit": 1, "offset": 1, "plan_id": "plan_id", "q": "q"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.CountUsersRequest{
		CompanyID: schematichq.String(
			"company_id",
		),
		PlanID: schematichq.String(
			"plan_id",
		),
		Q: schematichq.String(
			"q",
		),
		Limit: schematichq.Int(
			1,
		),
		Offset: schematichq.Int(
			1,
		),
	}
	_, invocationErr := client.Companies.CountUsers(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestCompaniesCreateUserWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Post(gowiremock.URLPathTemplate("/users/create")).WithBodyPattern(gowiremock.MatchesJsonSchema("{}", "V202012")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": map[string]interface{}{"company_memberships": []interface{}{map[string]interface{}{"company_id": "company_id", "created_at": "2024-01-15T09:30:00Z", "id": "id", "updated_at": "2024-01-15T09:30:00Z", "user_id": "user_id"}}, "created_at": "2024-01-15T09:30:00Z", "entity_traits": []interface{}{map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "definition_id": "definition_id", "environment_id": "environment_id", "id": "id", "updated_at": "2024-01-15T09:30:00Z", "value": "value"}}, "environment_id": "environment_id", "id": "id", "keys": []interface{}{map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "definition_id": "definition_id", "entity_id": "entity_id", "entity_type": "entity_type", "environment_id": "environment_id", "id": "id", "key": "key", "updated_at": "2024-01-15T09:30:00Z", "value": "value"}}, "last_seen_at": "2024-01-15T09:30:00Z", "name": "name", "traits": map[string]interface{}{"key": "value"}, "updated_at": "2024-01-15T09:30:00Z"}, "params": map[string]interface{}{"key": "value"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.UpsertUserRequestBody{
		Keys: map[string]string{
			"key": "value",
		},
	}
	_, invocationErr := client.Companies.CreateUser(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestCompaniesDeleteUserByKeysWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Post(gowiremock.URLPathTemplate("/users/delete")).WithBodyPattern(gowiremock.MatchesJsonSchema("{}", "V202012")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "environment_id": "environment_id", "id": "id", "last_seen_at": "2024-01-15T09:30:00Z", "name": "name", "updated_at": "2024-01-15T09:30:00Z"}, "params": map[string]interface{}{"key": "value"}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.KeysRequestBody{
		Keys: map[string]string{
			"key": "value",
		},
	}
	_, invocationErr := client.Companies.DeleteUserByKeys(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}

func TestCompaniesLookupUserWithWireMock(
	t *testing.T,
) {
	// wiremock client and server initialized in shared main_test.go
	defer WireMockClient.Reset()
	stub := gowiremock.Get(gowiremock.URLPathTemplate("/users/lookup")).WillReturnResponse(
		gowiremock.NewResponse().WithJSONBody(
			map[string]interface{}{"data": map[string]interface{}{"company_memberships": []interface{}{map[string]interface{}{"company": map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "environment_id": "environment_id", "id": "id", "last_seen_at": "2024-01-15T09:30:00Z", "logo_url": "logo_url", "name": "name", "updated_at": "2024-01-15T09:30:00Z"}, "company_id": "company_id", "created_at": "2024-01-15T09:30:00Z", "id": "id", "updated_at": "2024-01-15T09:30:00Z", "user_id": "user_id"}, map[string]interface{}{"company": map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "environment_id": "environment_id", "id": "id", "last_seen_at": "2024-01-15T09:30:00Z", "logo_url": "logo_url", "name": "name", "updated_at": "2024-01-15T09:30:00Z"}, "company_id": "company_id", "created_at": "2024-01-15T09:30:00Z", "id": "id", "updated_at": "2024-01-15T09:30:00Z", "user_id": "user_id"}}, "created_at": "2024-01-15T09:30:00Z", "entity_traits": []interface{}{map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "definition": map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "display_name": "display_name", "entity_type": "entity_type", "hierarchy": []interface{}{"hierarchy", "hierarchy"}, "id": "id", "trait_type": "trait_type", "updated_at": "2024-01-15T09:30:00Z"}, "definition_id": "definition_id", "environment_id": "environment_id", "id": "id", "updated_at": "2024-01-15T09:30:00Z", "value": "value"}, map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "definition": map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "display_name": "display_name", "entity_type": "entity_type", "hierarchy": []interface{}{"hierarchy", "hierarchy"}, "id": "id", "trait_type": "trait_type", "updated_at": "2024-01-15T09:30:00Z"}, "definition_id": "definition_id", "environment_id": "environment_id", "id": "id", "updated_at": "2024-01-15T09:30:00Z", "value": "value"}}, "environment_id": "environment_id", "id": "id", "keys": []interface{}{map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "definition": map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "entity_type": "entity_type", "id": "id", "key": "key", "updated_at": "2024-01-15T09:30:00Z"}, "definition_id": "definition_id", "entity_id": "entity_id", "entity_type": "entity_type", "environment_id": "environment_id", "id": "id", "key": "key", "updated_at": "2024-01-15T09:30:00Z", "value": "value"}, map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "definition": map[string]interface{}{"created_at": "2024-01-15T09:30:00Z", "entity_type": "entity_type", "id": "id", "key": "key", "updated_at": "2024-01-15T09:30:00Z"}, "definition_id": "definition_id", "entity_id": "entity_id", "entity_type": "entity_type", "environment_id": "environment_id", "id": "id", "key": "key", "updated_at": "2024-01-15T09:30:00Z", "value": "value"}}, "last_seen_at": "2024-01-15T09:30:00Z", "name": "name", "traits": map[string]interface{}{"traits": map[string]interface{}{"key": "value"}}, "updated_at": "2024-01-15T09:30:00Z"}, "params": map[string]interface{}{"keys": map[string]interface{}{"keys": "keys"}}},
		).WithStatus(http.StatusOK),
	)
	err := WireMockClient.StubFor(stub)
	require.NoError(t, err, "Failed to create WireMock stub")

	client := client.NewSchematicClient(
		option.WithBaseURL(
			WireMockBaseURL,
		),
	)
	request := &schematichq.LookupUserRequest{
		Keys: map[string]string{
			"keys": "keys",
		},
	}
	_, invocationErr := client.Companies.LookupUser(
		context.TODO(),
		request,
	)

	require.NoError(t, invocationErr, "Client method call should succeed")
	ok, countErr := WireMockClient.Verify(stub.Request(), 1)
	require.NoError(t, countErr, "Failed to verify WireMock request was matched")
	require.True(t, ok, "WireMock request was not matched")
}
