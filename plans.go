// This file was auto-generated by Fern from our API Definition.

package schematichq

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/schematichq/schematic-go/internal"
)

type CountPlansRequest struct {
	CompanyID *string `json:"-" url:"company_id,omitempty"`
	// Filter for plans valid as fallback plans (not linked to billing)
	ForFallbackPlan *bool `json:"-" url:"for_fallback_plan,omitempty"`
	// Filter for plans valid as initial plans (not linked to billing, free, or auto-cancelling trial)
	ForInitialPlan *bool `json:"-" url:"for_initial_plan,omitempty"`
	// Filter for plans valid as trial expiry plans (not linked to billing or free)
	ForTrialExpiryPlan *bool `json:"-" url:"for_trial_expiry_plan,omitempty"`
	// Filter out plans that do not have a billing product ID
	HasProductID *bool     `json:"-" url:"has_product_id,omitempty"`
	IDs          []*string `json:"-" url:"ids,omitempty"`
	// Filter by plan type
	PlanType *CountPlansRequestPlanType `json:"-" url:"plan_type,omitempty"`
	Q        *string                    `json:"-" url:"q,omitempty"`
	// Filter for plans that require a payment method (inverse of ForInitialPlan)
	RequiresPaymentMethod *bool `json:"-" url:"requires_payment_method,omitempty"`
	// Filter out plans that already have a plan entitlement for the specified feature ID
	WithoutEntitlementFor *string `json:"-" url:"without_entitlement_for,omitempty"`
	// Filter out plans that have a billing product ID
	WithoutProductID *bool `json:"-" url:"without_product_id,omitempty"`
	// Filter out plans that have a paid billing product ID
	WithoutPaidProductID *bool `json:"-" url:"without_paid_product_id,omitempty"`
	// Page limit (default 100)
	Limit *int `json:"-" url:"limit,omitempty"`
	// Page offset (default 0)
	Offset *int `json:"-" url:"offset,omitempty"`
}

type CreatePlanRequestBody struct {
	Description string                        `json:"description" url:"-"`
	Icon        *string                       `json:"icon,omitempty" url:"-"`
	Name        string                        `json:"name" url:"-"`
	PlanType    CreatePlanRequestBodyPlanType `json:"plan_type" url:"-"`
}

type ListPlanIssuesRequest struct {
	PlanID string `json:"-" url:"plan_id"`
}

type ListPlansRequest struct {
	CompanyID *string `json:"-" url:"company_id,omitempty"`
	// Filter for plans valid as fallback plans (not linked to billing)
	ForFallbackPlan *bool `json:"-" url:"for_fallback_plan,omitempty"`
	// Filter for plans valid as initial plans (not linked to billing, free, or auto-cancelling trial)
	ForInitialPlan *bool `json:"-" url:"for_initial_plan,omitempty"`
	// Filter for plans valid as trial expiry plans (not linked to billing or free)
	ForTrialExpiryPlan *bool `json:"-" url:"for_trial_expiry_plan,omitempty"`
	// Filter out plans that do not have a billing product ID
	HasProductID *bool     `json:"-" url:"has_product_id,omitempty"`
	IDs          []*string `json:"-" url:"ids,omitempty"`
	// Filter by plan type
	PlanType *ListPlansRequestPlanType `json:"-" url:"plan_type,omitempty"`
	Q        *string                   `json:"-" url:"q,omitempty"`
	// Filter for plans that require a payment method (inverse of ForInitialPlan)
	RequiresPaymentMethod *bool `json:"-" url:"requires_payment_method,omitempty"`
	// Filter out plans that already have a plan entitlement for the specified feature ID
	WithoutEntitlementFor *string `json:"-" url:"without_entitlement_for,omitempty"`
	// Filter out plans that have a billing product ID
	WithoutProductID *bool `json:"-" url:"without_product_id,omitempty"`
	// Filter out plans that have a paid billing product ID
	WithoutPaidProductID *bool `json:"-" url:"without_paid_product_id,omitempty"`
	// Page limit (default 100)
	Limit *int `json:"-" url:"limit,omitempty"`
	// Page offset (default 0)
	Offset *int `json:"-" url:"offset,omitempty"`
}

type BillingProductPlanResponseData struct {
	AccountID        string  `json:"account_id" url:"account_id"`
	BillingProductID string  `json:"billing_product_id" url:"billing_product_id"`
	ChargeType       string  `json:"charge_type" url:"charge_type"`
	ControlledBy     string  `json:"controlled_by" url:"controlled_by"`
	EnvironmentID    string  `json:"environment_id" url:"environment_id"`
	IsTrialable      bool    `json:"is_trialable" url:"is_trialable"`
	MonthlyPriceID   *string `json:"monthly_price_id,omitempty" url:"monthly_price_id,omitempty"`
	OneTimePriceID   *string `json:"one_time_price_id,omitempty" url:"one_time_price_id,omitempty"`
	PlanID           string  `json:"plan_id" url:"plan_id"`
	TrialDays        *int    `json:"trial_days,omitempty" url:"trial_days,omitempty"`
	YearlyPriceID    *string `json:"yearly_price_id,omitempty" url:"yearly_price_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BillingProductPlanResponseData) GetAccountID() string {
	if b == nil {
		return ""
	}
	return b.AccountID
}

func (b *BillingProductPlanResponseData) GetBillingProductID() string {
	if b == nil {
		return ""
	}
	return b.BillingProductID
}

func (b *BillingProductPlanResponseData) GetChargeType() string {
	if b == nil {
		return ""
	}
	return b.ChargeType
}

func (b *BillingProductPlanResponseData) GetControlledBy() string {
	if b == nil {
		return ""
	}
	return b.ControlledBy
}

func (b *BillingProductPlanResponseData) GetEnvironmentID() string {
	if b == nil {
		return ""
	}
	return b.EnvironmentID
}

func (b *BillingProductPlanResponseData) GetIsTrialable() bool {
	if b == nil {
		return false
	}
	return b.IsTrialable
}

func (b *BillingProductPlanResponseData) GetMonthlyPriceID() *string {
	if b == nil {
		return nil
	}
	return b.MonthlyPriceID
}

func (b *BillingProductPlanResponseData) GetOneTimePriceID() *string {
	if b == nil {
		return nil
	}
	return b.OneTimePriceID
}

func (b *BillingProductPlanResponseData) GetPlanID() string {
	if b == nil {
		return ""
	}
	return b.PlanID
}

func (b *BillingProductPlanResponseData) GetTrialDays() *int {
	if b == nil {
		return nil
	}
	return b.TrialDays
}

func (b *BillingProductPlanResponseData) GetYearlyPriceID() *string {
	if b == nil {
		return nil
	}
	return b.YearlyPriceID
}

func (b *BillingProductPlanResponseData) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BillingProductPlanResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler BillingProductPlanResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BillingProductPlanResponseData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BillingProductPlanResponseData) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type PlanIssueResponseData struct {
	Code        string  `json:"code" url:"code"`
	Description string  `json:"description" url:"description"`
	Detail      *string `json:"detail,omitempty" url:"detail,omitempty"`
	ID          *string `json:"id,omitempty" url:"id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PlanIssueResponseData) GetCode() string {
	if p == nil {
		return ""
	}
	return p.Code
}

func (p *PlanIssueResponseData) GetDescription() string {
	if p == nil {
		return ""
	}
	return p.Description
}

func (p *PlanIssueResponseData) GetDetail() *string {
	if p == nil {
		return nil
	}
	return p.Detail
}

func (p *PlanIssueResponseData) GetID() *string {
	if p == nil {
		return nil
	}
	return p.ID
}

func (p *PlanIssueResponseData) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PlanIssueResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PlanIssueResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PlanIssueResponseData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PlanIssueResponseData) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Input parameters
type CountPlansParams struct {
	CompanyID *string `json:"company_id,omitempty" url:"company_id,omitempty"`
	// Filter for plans valid as fallback plans (not linked to billing)
	ForFallbackPlan *bool `json:"for_fallback_plan,omitempty" url:"for_fallback_plan,omitempty"`
	// Filter for plans valid as initial plans (not linked to billing, free, or auto-cancelling trial)
	ForInitialPlan *bool `json:"for_initial_plan,omitempty" url:"for_initial_plan,omitempty"`
	// Filter for plans valid as trial expiry plans (not linked to billing or free)
	ForTrialExpiryPlan *bool `json:"for_trial_expiry_plan,omitempty" url:"for_trial_expiry_plan,omitempty"`
	// Filter out plans that do not have a billing product ID
	HasProductID *bool    `json:"has_product_id,omitempty" url:"has_product_id,omitempty"`
	IDs          []string `json:"ids,omitempty" url:"ids,omitempty"`
	// Page limit (default 100)
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// Page offset (default 0)
	Offset *int `json:"offset,omitempty" url:"offset,omitempty"`
	// Filter by plan type
	PlanType *CountPlansResponseParamsPlanType `json:"plan_type,omitempty" url:"plan_type,omitempty"`
	Q        *string                           `json:"q,omitempty" url:"q,omitempty"`
	// Filter for plans that require a payment method (inverse of ForInitialPlan)
	RequiresPaymentMethod *bool `json:"requires_payment_method,omitempty" url:"requires_payment_method,omitempty"`
	// Filter out plans that already have a plan entitlement for the specified feature ID
	WithoutEntitlementFor *string `json:"without_entitlement_for,omitempty" url:"without_entitlement_for,omitempty"`
	// Filter out plans that have a paid billing product ID
	WithoutPaidProductID *bool `json:"without_paid_product_id,omitempty" url:"without_paid_product_id,omitempty"`
	// Filter out plans that have a billing product ID
	WithoutProductID *bool `json:"without_product_id,omitempty" url:"without_product_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CountPlansParams) GetCompanyID() *string {
	if c == nil {
		return nil
	}
	return c.CompanyID
}

func (c *CountPlansParams) GetForFallbackPlan() *bool {
	if c == nil {
		return nil
	}
	return c.ForFallbackPlan
}

func (c *CountPlansParams) GetForInitialPlan() *bool {
	if c == nil {
		return nil
	}
	return c.ForInitialPlan
}

func (c *CountPlansParams) GetForTrialExpiryPlan() *bool {
	if c == nil {
		return nil
	}
	return c.ForTrialExpiryPlan
}

func (c *CountPlansParams) GetHasProductID() *bool {
	if c == nil {
		return nil
	}
	return c.HasProductID
}

func (c *CountPlansParams) GetIDs() []string {
	if c == nil {
		return nil
	}
	return c.IDs
}

func (c *CountPlansParams) GetLimit() *int {
	if c == nil {
		return nil
	}
	return c.Limit
}

func (c *CountPlansParams) GetOffset() *int {
	if c == nil {
		return nil
	}
	return c.Offset
}

func (c *CountPlansParams) GetPlanType() *CountPlansResponseParamsPlanType {
	if c == nil {
		return nil
	}
	return c.PlanType
}

func (c *CountPlansParams) GetQ() *string {
	if c == nil {
		return nil
	}
	return c.Q
}

func (c *CountPlansParams) GetRequiresPaymentMethod() *bool {
	if c == nil {
		return nil
	}
	return c.RequiresPaymentMethod
}

func (c *CountPlansParams) GetWithoutEntitlementFor() *string {
	if c == nil {
		return nil
	}
	return c.WithoutEntitlementFor
}

func (c *CountPlansParams) GetWithoutPaidProductID() *bool {
	if c == nil {
		return nil
	}
	return c.WithoutPaidProductID
}

func (c *CountPlansParams) GetWithoutProductID() *bool {
	if c == nil {
		return nil
	}
	return c.WithoutProductID
}

func (c *CountPlansParams) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CountPlansParams) UnmarshalJSON(data []byte) error {
	type unmarshaler CountPlansParams
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CountPlansParams(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CountPlansParams) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Filter by plan type
type CountPlansRequestPlanType string

const (
	CountPlansRequestPlanTypePlan  CountPlansRequestPlanType = "plan"
	CountPlansRequestPlanTypeAddOn CountPlansRequestPlanType = "add_on"
)

func NewCountPlansRequestPlanTypeFromString(s string) (CountPlansRequestPlanType, error) {
	switch s {
	case "plan":
		return CountPlansRequestPlanTypePlan, nil
	case "add_on":
		return CountPlansRequestPlanTypeAddOn, nil
	}
	var t CountPlansRequestPlanType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CountPlansRequestPlanType) Ptr() *CountPlansRequestPlanType {
	return &c
}

type CountPlansResponse struct {
	Data *CountResponse `json:"data,omitempty" url:"data,omitempty"`
	// Input parameters
	Params *CountPlansParams `json:"params,omitempty" url:"params,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CountPlansResponse) GetData() *CountResponse {
	if c == nil {
		return nil
	}
	return c.Data
}

func (c *CountPlansResponse) GetParams() *CountPlansParams {
	if c == nil {
		return nil
	}
	return c.Params
}

func (c *CountPlansResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CountPlansResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CountPlansResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CountPlansResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CountPlansResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Filter by plan type
type CountPlansResponseParamsPlanType string

const (
	CountPlansResponseParamsPlanTypePlan  CountPlansResponseParamsPlanType = "plan"
	CountPlansResponseParamsPlanTypeAddOn CountPlansResponseParamsPlanType = "add_on"
)

func NewCountPlansResponseParamsPlanTypeFromString(s string) (CountPlansResponseParamsPlanType, error) {
	switch s {
	case "plan":
		return CountPlansResponseParamsPlanTypePlan, nil
	case "add_on":
		return CountPlansResponseParamsPlanTypeAddOn, nil
	}
	var t CountPlansResponseParamsPlanType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CountPlansResponseParamsPlanType) Ptr() *CountPlansResponseParamsPlanType {
	return &c
}

type CreatePlanRequestBodyPlanType string

const (
	CreatePlanRequestBodyPlanTypePlan  CreatePlanRequestBodyPlanType = "plan"
	CreatePlanRequestBodyPlanTypeAddOn CreatePlanRequestBodyPlanType = "add_on"
)

func NewCreatePlanRequestBodyPlanTypeFromString(s string) (CreatePlanRequestBodyPlanType, error) {
	switch s {
	case "plan":
		return CreatePlanRequestBodyPlanTypePlan, nil
	case "add_on":
		return CreatePlanRequestBodyPlanTypeAddOn, nil
	}
	var t CreatePlanRequestBodyPlanType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreatePlanRequestBodyPlanType) Ptr() *CreatePlanRequestBodyPlanType {
	return &c
}

type CreatePlanResponse struct {
	Data *PlanDetailResponseData `json:"data,omitempty" url:"data,omitempty"`
	// Input parameters
	Params map[string]interface{} `json:"params,omitempty" url:"params,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreatePlanResponse) GetData() *PlanDetailResponseData {
	if c == nil {
		return nil
	}
	return c.Data
}

func (c *CreatePlanResponse) GetParams() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.Params
}

func (c *CreatePlanResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreatePlanResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreatePlanResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreatePlanResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreatePlanResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type DeletePlanResponse struct {
	Data *DeleteResponse `json:"data,omitempty" url:"data,omitempty"`
	// Input parameters
	Params map[string]interface{} `json:"params,omitempty" url:"params,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeletePlanResponse) GetData() *DeleteResponse {
	if d == nil {
		return nil
	}
	return d.Data
}

func (d *DeletePlanResponse) GetParams() map[string]interface{} {
	if d == nil {
		return nil
	}
	return d.Params
}

func (d *DeletePlanResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeletePlanResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeletePlanResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeletePlanResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeletePlanResponse) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type GetPlanResponse struct {
	Data *PlanDetailResponseData `json:"data,omitempty" url:"data,omitempty"`
	// Input parameters
	Params map[string]interface{} `json:"params,omitempty" url:"params,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetPlanResponse) GetData() *PlanDetailResponseData {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GetPlanResponse) GetParams() map[string]interface{} {
	if g == nil {
		return nil
	}
	return g.Params
}

func (g *GetPlanResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetPlanResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetPlanResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetPlanResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetPlanResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Input parameters
type ListPlanIssuesParams struct {
	PlanID *string `json:"plan_id,omitempty" url:"plan_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListPlanIssuesParams) GetPlanID() *string {
	if l == nil {
		return nil
	}
	return l.PlanID
}

func (l *ListPlanIssuesParams) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListPlanIssuesParams) UnmarshalJSON(data []byte) error {
	type unmarshaler ListPlanIssuesParams
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListPlanIssuesParams(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListPlanIssuesParams) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListPlanIssuesResponse struct {
	Data []*PlanIssueResponseData `json:"data,omitempty" url:"data,omitempty"`
	// Input parameters
	Params *ListPlanIssuesParams `json:"params,omitempty" url:"params,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListPlanIssuesResponse) GetData() []*PlanIssueResponseData {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *ListPlanIssuesResponse) GetParams() *ListPlanIssuesParams {
	if l == nil {
		return nil
	}
	return l.Params
}

func (l *ListPlanIssuesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListPlanIssuesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListPlanIssuesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListPlanIssuesResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListPlanIssuesResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Input parameters
type ListPlansParams struct {
	CompanyID *string `json:"company_id,omitempty" url:"company_id,omitempty"`
	// Filter for plans valid as fallback plans (not linked to billing)
	ForFallbackPlan *bool `json:"for_fallback_plan,omitempty" url:"for_fallback_plan,omitempty"`
	// Filter for plans valid as initial plans (not linked to billing, free, or auto-cancelling trial)
	ForInitialPlan *bool `json:"for_initial_plan,omitempty" url:"for_initial_plan,omitempty"`
	// Filter for plans valid as trial expiry plans (not linked to billing or free)
	ForTrialExpiryPlan *bool `json:"for_trial_expiry_plan,omitempty" url:"for_trial_expiry_plan,omitempty"`
	// Filter out plans that do not have a billing product ID
	HasProductID *bool    `json:"has_product_id,omitempty" url:"has_product_id,omitempty"`
	IDs          []string `json:"ids,omitempty" url:"ids,omitempty"`
	// Page limit (default 100)
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// Page offset (default 0)
	Offset *int `json:"offset,omitempty" url:"offset,omitempty"`
	// Filter by plan type
	PlanType *ListPlansResponseParamsPlanType `json:"plan_type,omitempty" url:"plan_type,omitempty"`
	Q        *string                          `json:"q,omitempty" url:"q,omitempty"`
	// Filter for plans that require a payment method (inverse of ForInitialPlan)
	RequiresPaymentMethod *bool `json:"requires_payment_method,omitempty" url:"requires_payment_method,omitempty"`
	// Filter out plans that already have a plan entitlement for the specified feature ID
	WithoutEntitlementFor *string `json:"without_entitlement_for,omitempty" url:"without_entitlement_for,omitempty"`
	// Filter out plans that have a paid billing product ID
	WithoutPaidProductID *bool `json:"without_paid_product_id,omitempty" url:"without_paid_product_id,omitempty"`
	// Filter out plans that have a billing product ID
	WithoutProductID *bool `json:"without_product_id,omitempty" url:"without_product_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListPlansParams) GetCompanyID() *string {
	if l == nil {
		return nil
	}
	return l.CompanyID
}

func (l *ListPlansParams) GetForFallbackPlan() *bool {
	if l == nil {
		return nil
	}
	return l.ForFallbackPlan
}

func (l *ListPlansParams) GetForInitialPlan() *bool {
	if l == nil {
		return nil
	}
	return l.ForInitialPlan
}

func (l *ListPlansParams) GetForTrialExpiryPlan() *bool {
	if l == nil {
		return nil
	}
	return l.ForTrialExpiryPlan
}

func (l *ListPlansParams) GetHasProductID() *bool {
	if l == nil {
		return nil
	}
	return l.HasProductID
}

func (l *ListPlansParams) GetIDs() []string {
	if l == nil {
		return nil
	}
	return l.IDs
}

func (l *ListPlansParams) GetLimit() *int {
	if l == nil {
		return nil
	}
	return l.Limit
}

func (l *ListPlansParams) GetOffset() *int {
	if l == nil {
		return nil
	}
	return l.Offset
}

func (l *ListPlansParams) GetPlanType() *ListPlansResponseParamsPlanType {
	if l == nil {
		return nil
	}
	return l.PlanType
}

func (l *ListPlansParams) GetQ() *string {
	if l == nil {
		return nil
	}
	return l.Q
}

func (l *ListPlansParams) GetRequiresPaymentMethod() *bool {
	if l == nil {
		return nil
	}
	return l.RequiresPaymentMethod
}

func (l *ListPlansParams) GetWithoutEntitlementFor() *string {
	if l == nil {
		return nil
	}
	return l.WithoutEntitlementFor
}

func (l *ListPlansParams) GetWithoutPaidProductID() *bool {
	if l == nil {
		return nil
	}
	return l.WithoutPaidProductID
}

func (l *ListPlansParams) GetWithoutProductID() *bool {
	if l == nil {
		return nil
	}
	return l.WithoutProductID
}

func (l *ListPlansParams) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListPlansParams) UnmarshalJSON(data []byte) error {
	type unmarshaler ListPlansParams
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListPlansParams(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListPlansParams) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Filter by plan type
type ListPlansRequestPlanType string

const (
	ListPlansRequestPlanTypePlan  ListPlansRequestPlanType = "plan"
	ListPlansRequestPlanTypeAddOn ListPlansRequestPlanType = "add_on"
)

func NewListPlansRequestPlanTypeFromString(s string) (ListPlansRequestPlanType, error) {
	switch s {
	case "plan":
		return ListPlansRequestPlanTypePlan, nil
	case "add_on":
		return ListPlansRequestPlanTypeAddOn, nil
	}
	var t ListPlansRequestPlanType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l ListPlansRequestPlanType) Ptr() *ListPlansRequestPlanType {
	return &l
}

type ListPlansResponse struct {
	Data []*PlanDetailResponseData `json:"data,omitempty" url:"data,omitempty"`
	// Input parameters
	Params *ListPlansParams `json:"params,omitempty" url:"params,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListPlansResponse) GetData() []*PlanDetailResponseData {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *ListPlansResponse) GetParams() *ListPlansParams {
	if l == nil {
		return nil
	}
	return l.Params
}

func (l *ListPlansResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListPlansResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListPlansResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListPlansResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListPlansResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Filter by plan type
type ListPlansResponseParamsPlanType string

const (
	ListPlansResponseParamsPlanTypePlan  ListPlansResponseParamsPlanType = "plan"
	ListPlansResponseParamsPlanTypeAddOn ListPlansResponseParamsPlanType = "add_on"
)

func NewListPlansResponseParamsPlanTypeFromString(s string) (ListPlansResponseParamsPlanType, error) {
	switch s {
	case "plan":
		return ListPlansResponseParamsPlanTypePlan, nil
	case "add_on":
		return ListPlansResponseParamsPlanTypeAddOn, nil
	}
	var t ListPlansResponseParamsPlanType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l ListPlansResponseParamsPlanType) Ptr() *ListPlansResponseParamsPlanType {
	return &l
}

type UpdateCompanyPlansResponse struct {
	Data *CompanyDetailResponseData `json:"data,omitempty" url:"data,omitempty"`
	// Input parameters
	Params map[string]interface{} `json:"params,omitempty" url:"params,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateCompanyPlansResponse) GetData() *CompanyDetailResponseData {
	if u == nil {
		return nil
	}
	return u.Data
}

func (u *UpdateCompanyPlansResponse) GetParams() map[string]interface{} {
	if u == nil {
		return nil
	}
	return u.Params
}

func (u *UpdateCompanyPlansResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateCompanyPlansResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateCompanyPlansResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateCompanyPlansResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateCompanyPlansResponse) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdatePlanResponse struct {
	Data *PlanDetailResponseData `json:"data,omitempty" url:"data,omitempty"`
	// Input parameters
	Params map[string]interface{} `json:"params,omitempty" url:"params,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdatePlanResponse) GetData() *PlanDetailResponseData {
	if u == nil {
		return nil
	}
	return u.Data
}

func (u *UpdatePlanResponse) GetParams() map[string]interface{} {
	if u == nil {
		return nil
	}
	return u.Params
}

func (u *UpdatePlanResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdatePlanResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdatePlanResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdatePlanResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdatePlanResponse) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpsertBillingProductPlanResponse struct {
	Data *BillingProductPlanResponseData `json:"data,omitempty" url:"data,omitempty"`
	// Input parameters
	Params map[string]interface{} `json:"params,omitempty" url:"params,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpsertBillingProductPlanResponse) GetData() *BillingProductPlanResponseData {
	if u == nil {
		return nil
	}
	return u.Data
}

func (u *UpsertBillingProductPlanResponse) GetParams() map[string]interface{} {
	if u == nil {
		return nil
	}
	return u.Params
}

func (u *UpsertBillingProductPlanResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpsertBillingProductPlanResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpsertBillingProductPlanResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpsertBillingProductPlanResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpsertBillingProductPlanResponse) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpsertBillingProductRequestBodyChargeType string

const (
	UpsertBillingProductRequestBodyChargeTypeOneTime   UpsertBillingProductRequestBodyChargeType = "one_time"
	UpsertBillingProductRequestBodyChargeTypeRecurring UpsertBillingProductRequestBodyChargeType = "recurring"
	UpsertBillingProductRequestBodyChargeTypeFree      UpsertBillingProductRequestBodyChargeType = "free"
)

func NewUpsertBillingProductRequestBodyChargeTypeFromString(s string) (UpsertBillingProductRequestBodyChargeType, error) {
	switch s {
	case "one_time":
		return UpsertBillingProductRequestBodyChargeTypeOneTime, nil
	case "recurring":
		return UpsertBillingProductRequestBodyChargeTypeRecurring, nil
	case "free":
		return UpsertBillingProductRequestBodyChargeTypeFree, nil
	}
	var t UpsertBillingProductRequestBodyChargeType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpsertBillingProductRequestBodyChargeType) Ptr() *UpsertBillingProductRequestBodyChargeType {
	return &u
}

type UpdateCompanyPlansRequestBody struct {
	AddOnIDs   []string `json:"add_on_ids,omitempty" url:"-"`
	BasePlanID *string  `json:"base_plan_id,omitempty" url:"-"`
}

type UpdatePlanRequestBody struct {
	Description *string `json:"description,omitempty" url:"-"`
	Icon        *string `json:"icon,omitempty" url:"-"`
	Name        string  `json:"name" url:"-"`
}

type UpsertBillingProductRequestBody struct {
	BillingProductID *string                                   `json:"billing_product_id,omitempty" url:"-"`
	ChargeType       UpsertBillingProductRequestBodyChargeType `json:"charge_type" url:"-"`
	Currency         *string                                   `json:"currency,omitempty" url:"-"`
	IsTrialable      bool                                      `json:"is_trialable" url:"-"`
	MonthlyPrice     *int                                      `json:"monthly_price,omitempty" url:"-"`
	MonthlyPriceID   *string                                   `json:"monthly_price_id,omitempty" url:"-"`
	OneTimePrice     *int                                      `json:"one_time_price,omitempty" url:"-"`
	OneTimePriceID   *string                                   `json:"one_time_price_id,omitempty" url:"-"`
	TrialDays        *int                                      `json:"trial_days,omitempty" url:"-"`
	YearlyPrice      *int                                      `json:"yearly_price,omitempty" url:"-"`
	YearlyPriceID    *string                                   `json:"yearly_price_id,omitempty" url:"-"`
}
